# Интеграция парсера автомобилей в Backend

## Что было сделано

### 1. Создан модуль парсера (`car_parser.py`)

- **Класс `CarParser`** - основной класс для парсинга автомобилей с сайта aaa-motors.ru
- **Методы:**
  - `generate_car_link()` - генерирует ссылку на каталог по марке и модели
  - `find_car_by_price()` - находит автомобиль по цене на странице каталога
  - `parse_cars_from_html()` - парсит HTML и извлекает информацию об автомобилях
  - `extract_car_info()` - извлекает информацию из карточки автомобиля
  - `extract_price_from_text()` - извлекает цену из текста

### 2. Добавлены API endpoints в `app.py`

- **`POST /api/car/parse`** - найти автомобиль по цене
  - Принимает: `brand`, `model`, `price`, `tolerance`
  - Возвращает: информацию о найденном автомобиле или ошибку

- **`POST /api/car/link`** - сгенерировать ссылку на каталог
  - Принимает: `brand`, `model`
  - Возвращает: URL каталога

- **`GET /api/car/parse/{car_id}`** - найти автомобиль из БД на сайте
  - Принимает: ID автомобиля из базы данных
  - Возвращает: сравнение данных из БД и с сайта

### 3. Обновлен фронтенд (`static/index_new.html`)

- **Удалены старые клиентские функции парсинга:**
  - `findCarByPrice()`
  - `parseCarsFromHtml()`
  - `extractCarInfo()`
  - `extractPriceFromText()`
  - `findMatchingCar()`

- **Добавлена новая функция:**
  - `generateCarLinkWithParsing()` - теперь использует backend API вместо клиентского парсинга

### 4. Добавлены зависимости

- `beautifulsoup4==4.12.2` - для парсинга HTML
- Обновлен `requirements.txt`

## Структура парсера

### Маппинги для URL

**Марки:**
```python
brand_mapping = {
    'BMW': 'bmw',
    'AITO': 'aito',
    'AUDI': 'audi',
    # ... и другие
}
```

**Модели:**
```python
model_mapping = {
    'X5': 'x5',
    'M7': 'm7',
    'A6': 'a6',
    # ... и другие
}
```

### Селекторы для парсинга

Парсер использует следующие селекторы для извлечения данных:
- Карточки: `a.item-row.js-item`
- Цена: `div.item__price-main`
- Название: `div.item__title.js-item-title`
- Тех. характеристики: `div.item__tech`
- Статус: `span.item-row__info-status`
- Адрес: `div.item-row__info-address`

## Использование

### Через API

```bash
# Найти автомобиль по цене
curl -X POST http://localhost:5000/api/car/parse \
  -H "Content-Type: application/json" \
  -d '{
    "brand": "AITO",
    "model": "M7",
    "price": 7541000,
    "tolerance": 0.1
  }'

# Сгенерировать ссылку
curl -X POST http://localhost:5000/api/car/link \
  -H "Content-Type: application/json" \
  -d '{
    "brand": "BMW",
    "model": "X5"
  }'
```

### Через фронтенд

Функция `generateCarLinkWithParsing()` автоматически:
1. Вызывает backend API для парсинга
2. При неудаче использует fallback к базовой ссылке
3. Обрабатывает ошибки и таймауты

## Преимущества новой архитектуры

1. **Производительность** - парсинг происходит на сервере, а не в браузере
2. **Надежность** - нет проблем с CORS и прокси
3. **Масштабируемость** - можно добавить кэширование и rate limiting
4. **Безопасность** - серверные запросы более контролируемы
5. **Логирование** - все запросы логируются на сервере

## Тестирование

Создан тестовый скрипт `test_parser.py` для проверки работы API:

```bash
python test_parser.py
```

## Логирование

Парсер использует стандартное логирование Python:
- INFO: успешные операции
- WARNING: предупреждения (например, недостаточно данных)
- ERROR: ошибки парсинга и сетевые проблемы

## Возможные улучшения

1. **Кэширование** - кэшировать результаты парсинга
2. **Rate limiting** - ограничить частоту запросов к сайту
3. **Прокси** - добавить поддержку прокси для обхода блокировок
4. **Асинхронность** - использовать aiohttp для асинхронных запросов
5. **Валидация** - добавить валидацию входных данных
6. **Мониторинг** - добавить метрики успешности парсинга 