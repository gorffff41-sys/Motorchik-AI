[
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "BadZipFile",
        "importPath": "zipfile",
        "description": "zipfile",
        "isExtraImport": true,
        "detail": "zipfile",
        "documentation": {}
    },
    {
        "label": "ZipFile",
        "importPath": "zipfile",
        "description": "zipfile",
        "isExtraImport": true,
        "detail": "zipfile",
        "documentation": {}
    },
    {
        "label": "sqlite3",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sqlite3",
        "description": "sqlite3",
        "detail": "sqlite3",
        "documentation": {}
    },
    {
        "label": "tabulate",
        "importPath": "tabulate",
        "description": "tabulate",
        "isExtraImport": true,
        "detail": "tabulate",
        "documentation": {}
    },
    {
        "label": "FastAPI",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "HTTPException",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Request",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Body",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Query",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Header",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Depends",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "HTMLResponse",
        "importPath": "fastapi.responses",
        "description": "fastapi.responses",
        "isExtraImport": true,
        "detail": "fastapi.responses",
        "documentation": {}
    },
    {
        "label": "JSONResponse",
        "importPath": "fastapi.responses",
        "description": "fastapi.responses",
        "isExtraImport": true,
        "detail": "fastapi.responses",
        "documentation": {}
    },
    {
        "label": "StaticFiles",
        "importPath": "fastapi.staticfiles",
        "description": "fastapi.staticfiles",
        "isExtraImport": true,
        "detail": "fastapi.staticfiles",
        "documentation": {}
    },
    {
        "label": "CORSMiddleware",
        "importPath": "fastapi.middleware.cors",
        "description": "fastapi.middleware.cors",
        "isExtraImport": true,
        "detail": "fastapi.middleware.cors",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "HTTP_401_UNAUTHORIZED",
        "importPath": "starlette.status",
        "description": "starlette.status",
        "isExtraImport": true,
        "detail": "starlette.status",
        "documentation": {}
    },
    {
        "label": "secrets",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "secrets",
        "description": "secrets",
        "detail": "secrets",
        "documentation": {}
    },
    {
        "label": "traceback",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "traceback",
        "description": "traceback",
        "detail": "traceback",
        "documentation": {}
    },
    {
        "label": "request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "g",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "execute_query",
        "importPath": "database",
        "description": "database",
        "isExtraImport": true,
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "get_db",
        "importPath": "database",
        "description": "database",
        "isExtraImport": true,
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "search_all_cars",
        "importPath": "database",
        "description": "database",
        "isExtraImport": true,
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "get_all_brands_cached",
        "importPath": "database",
        "description": "database",
        "isExtraImport": true,
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "get_all_models_cached",
        "importPath": "database",
        "description": "database",
        "isExtraImport": true,
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "smart_filter_cars",
        "importPath": "database",
        "description": "database",
        "isExtraImport": true,
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "get_recent_cars_from_db",
        "importPath": "database",
        "description": "database",
        "isExtraImport": true,
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "get_all_quick_scenarios",
        "importPath": "database",
        "description": "database",
        "isExtraImport": true,
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "add_quick_scenario",
        "importPath": "database",
        "description": "database",
        "isExtraImport": true,
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "update_quick_scenario",
        "importPath": "database",
        "description": "database",
        "isExtraImport": true,
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "delete_quick_scenario",
        "importPath": "database",
        "description": "database",
        "isExtraImport": true,
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "init_quick_scenarios_table",
        "importPath": "database",
        "description": "database",
        "isExtraImport": true,
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "get_all_cities",
        "importPath": "database",
        "description": "database",
        "isExtraImport": true,
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "get_all_options",
        "importPath": "database",
        "description": "database",
        "isExtraImport": true,
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "get_all_unique_values_lower",
        "importPath": "database",
        "description": "database",
        "isExtraImport": true,
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "CacheManager",
        "importPath": "database",
        "description": "database",
        "isExtraImport": true,
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "get_car_options",
        "importPath": "database",
        "description": "database",
        "isExtraImport": true,
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "get_full_car_info",
        "importPath": "database",
        "description": "database",
        "isExtraImport": true,
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "compare_cars",
        "importPath": "database",
        "description": "database",
        "isExtraImport": true,
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "filter_cars",
        "importPath": "database",
        "description": "database",
        "isExtraImport": true,
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "get_all_brands",
        "importPath": "database",
        "description": "database",
        "isExtraImport": true,
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "get_all_models",
        "importPath": "database",
        "description": "database",
        "isExtraImport": true,
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "get_dealer_centers_for_car",
        "importPath": "database",
        "description": "database",
        "isExtraImport": true,
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "get_dealer_center_info_by_code",
        "importPath": "database",
        "description": "database",
        "isExtraImport": true,
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "smart_filter_cars",
        "importPath": "database",
        "description": "database",
        "isExtraImport": true,
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "get_all_dealer_centers",
        "importPath": "database",
        "description": "database",
        "isExtraImport": true,
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "# get_car_details",
        "importPath": "database",
        "description": "database",
        "isExtraImport": true,
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "# удалён",
        "importPath": "database",
        "description": "database",
        "isExtraImport": true,
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "чтобы не было ошибки импорта\n    get_dealer_center_info",
        "importPath": "database",
        "description": "database",
        "isExtraImport": true,
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "get_dealer_centers_for_car",
        "importPath": "database",
        "description": "database",
        "isExtraImport": true,
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "compare_cars",
        "importPath": "database",
        "description": "database",
        "isExtraImport": true,
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "get_recent_cars_from_db",
        "importPath": "database",
        "description": "database",
        "isExtraImport": true,
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "search_all_cars",
        "importPath": "database",
        "description": "database",
        "isExtraImport": true,
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "get_full_car_info",
        "importPath": "database",
        "description": "database",
        "isExtraImport": true,
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "execute_query",
        "importPath": "database",
        "description": "database",
        "isExtraImport": true,
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "get_db",
        "importPath": "database",
        "description": "database",
        "isExtraImport": true,
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "get_db",
        "importPath": "database",
        "description": "database",
        "isExtraImport": true,
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "search_all_cars",
        "importPath": "database",
        "description": "database",
        "isExtraImport": true,
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "get_db",
        "importPath": "database",
        "description": "database",
        "isExtraImport": true,
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "get_db",
        "importPath": "database",
        "description": "database",
        "isExtraImport": true,
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "DialogManager",
        "importPath": "dialog_manager",
        "description": "dialog_manager",
        "isExtraImport": true,
        "detail": "dialog_manager",
        "documentation": {}
    },
    {
        "label": "ContextAwareDialogManager",
        "importPath": "dialog_manager",
        "description": "dialog_manager",
        "isExtraImport": true,
        "detail": "dialog_manager",
        "documentation": {}
    },
    {
        "label": "NLPProcessor",
        "importPath": "nlp_processor",
        "description": "nlp_processor",
        "isExtraImport": true,
        "detail": "nlp_processor",
        "documentation": {}
    },
    {
        "label": "extract_entities_from_text",
        "importPath": "nlp_processor",
        "description": "nlp_processor",
        "isExtraImport": true,
        "detail": "nlp_processor",
        "documentation": {}
    },
    {
        "label": "NLPProcessor",
        "importPath": "nlp_processor",
        "description": "nlp_processor",
        "isExtraImport": true,
        "detail": "nlp_processor",
        "documentation": {}
    },
    {
        "label": "extract_down_payment",
        "importPath": "nlp_processor",
        "description": "nlp_processor",
        "isExtraImport": true,
        "detail": "nlp_processor",
        "documentation": {}
    },
    {
        "label": "extract_term",
        "importPath": "nlp_processor",
        "description": "nlp_processor",
        "isExtraImport": true,
        "detail": "nlp_processor",
        "documentation": {}
    },
    {
        "label": "extract_price",
        "importPath": "nlp_processor",
        "description": "nlp_processor",
        "isExtraImport": true,
        "detail": "nlp_processor",
        "documentation": {}
    },
    {
        "label": "extract_year",
        "importPath": "nlp_processor",
        "description": "nlp_processor",
        "isExtraImport": true,
        "detail": "nlp_processor",
        "documentation": {}
    },
    {
        "label": "extract_mileage",
        "importPath": "nlp_processor",
        "description": "nlp_processor",
        "isExtraImport": true,
        "detail": "nlp_processor",
        "documentation": {}
    },
    {
        "label": "extract_contact",
        "importPath": "nlp_processor",
        "description": "nlp_processor",
        "isExtraImport": true,
        "detail": "nlp_processor",
        "documentation": {}
    },
    {
        "label": "extract_date",
        "importPath": "nlp_processor",
        "description": "nlp_processor",
        "isExtraImport": true,
        "detail": "nlp_processor",
        "documentation": {}
    },
    {
        "label": "extract_price_range",
        "importPath": "nlp_processor",
        "description": "nlp_processor",
        "isExtraImport": true,
        "detail": "nlp_processor",
        "documentation": {}
    },
    {
        "label": "extract_year_range",
        "importPath": "nlp_processor",
        "description": "nlp_processor",
        "isExtraImport": true,
        "detail": "nlp_processor",
        "documentation": {}
    },
    {
        "label": "extract_city",
        "importPath": "nlp_processor",
        "description": "nlp_processor",
        "isExtraImport": true,
        "detail": "nlp_processor",
        "documentation": {}
    },
    {
        "label": "NLPProcessor",
        "importPath": "nlp_processor",
        "description": "nlp_processor",
        "isExtraImport": true,
        "detail": "nlp_processor",
        "documentation": {}
    },
    {
        "label": "extract_entities_from_text",
        "importPath": "nlp_processor",
        "description": "nlp_processor",
        "isExtraImport": true,
        "detail": "nlp_processor",
        "documentation": {}
    },
    {
        "label": "NLPProcessor",
        "importPath": "nlp_processor",
        "description": "nlp_processor",
        "isExtraImport": true,
        "detail": "nlp_processor",
        "documentation": {}
    },
    {
        "label": "NLPProcessor",
        "importPath": "nlp_processor",
        "description": "nlp_processor",
        "isExtraImport": true,
        "detail": "nlp_processor",
        "documentation": {}
    },
    {
        "label": "NLPProcessor",
        "importPath": "nlp_processor",
        "description": "nlp_processor",
        "isExtraImport": true,
        "detail": "nlp_processor",
        "documentation": {}
    },
    {
        "label": "NLPProcessor",
        "importPath": "nlp_processor",
        "description": "nlp_processor",
        "isExtraImport": true,
        "detail": "nlp_processor",
        "documentation": {}
    },
    {
        "label": "NLPProcessor",
        "importPath": "nlp_processor",
        "description": "nlp_processor",
        "isExtraImport": true,
        "detail": "nlp_processor",
        "documentation": {}
    },
    {
        "label": "NLPProcessor",
        "importPath": "nlp_processor",
        "description": "nlp_processor",
        "isExtraImport": true,
        "detail": "nlp_processor",
        "documentation": {}
    },
    {
        "label": "NLPProcessor",
        "importPath": "nlp_processor",
        "description": "nlp_processor",
        "isExtraImport": true,
        "detail": "nlp_processor",
        "documentation": {}
    },
    {
        "label": "NLPProcessor",
        "importPath": "nlp_processor",
        "description": "nlp_processor",
        "isExtraImport": true,
        "detail": "nlp_processor",
        "documentation": {}
    },
    {
        "label": "NLPProcessor",
        "importPath": "nlp_processor",
        "description": "nlp_processor",
        "isExtraImport": true,
        "detail": "nlp_processor",
        "documentation": {}
    },
    {
        "label": "NLPProcessor",
        "importPath": "nlp_processor",
        "description": "nlp_processor",
        "isExtraImport": true,
        "detail": "nlp_processor",
        "documentation": {}
    },
    {
        "label": "NLPProcessor",
        "importPath": "nlp_processor",
        "description": "nlp_processor",
        "isExtraImport": true,
        "detail": "nlp_processor",
        "documentation": {}
    },
    {
        "label": "NLPProcessor",
        "importPath": "nlp_processor",
        "description": "nlp_processor",
        "isExtraImport": true,
        "detail": "nlp_processor",
        "documentation": {}
    },
    {
        "label": "extract_model_from_text",
        "importPath": "nlp_processor",
        "description": "nlp_processor",
        "isExtraImport": true,
        "detail": "nlp_processor",
        "documentation": {}
    },
    {
        "label": "extract_entities_from_text",
        "importPath": "nlp_processor",
        "description": "nlp_processor",
        "isExtraImport": true,
        "detail": "nlp_processor",
        "documentation": {}
    },
    {
        "label": "FuzzySearch",
        "importPath": "fuzzy_search",
        "description": "fuzzy_search",
        "isExtraImport": true,
        "detail": "fuzzy_search",
        "documentation": {}
    },
    {
        "label": "FuzzySearch",
        "importPath": "fuzzy_search",
        "description": "fuzzy_search",
        "isExtraImport": true,
        "detail": "fuzzy_search",
        "documentation": {}
    },
    {
        "label": "find_similar_words",
        "importPath": "nlp_utils",
        "description": "nlp_utils",
        "isExtraImport": true,
        "detail": "nlp_utils",
        "documentation": {}
    },
    {
        "label": "extract_entities",
        "importPath": "nlp_utils",
        "description": "nlp_utils",
        "isExtraImport": true,
        "detail": "nlp_utils",
        "documentation": {}
    },
    {
        "label": "UserHistory",
        "importPath": "user_history",
        "description": "user_history",
        "isExtraImport": true,
        "detail": "user_history",
        "documentation": {}
    },
    {
        "label": "UserHistory",
        "importPath": "user_history",
        "description": "user_history",
        "isExtraImport": true,
        "detail": "user_history",
        "documentation": {}
    },
    {
        "label": "UserHistory",
        "importPath": "user_history",
        "description": "user_history",
        "isExtraImport": true,
        "detail": "user_history",
        "documentation": {}
    },
    {
        "label": "user_history",
        "importPath": "user_history",
        "description": "user_history",
        "isExtraImport": true,
        "detail": "user_history",
        "documentation": {}
    },
    {
        "label": "UserHistory",
        "importPath": "user_history",
        "description": "user_history",
        "isExtraImport": true,
        "detail": "user_history",
        "documentation": {}
    },
    {
        "label": "UserHistory",
        "importPath": "user_history",
        "description": "user_history",
        "isExtraImport": true,
        "detail": "user_history",
        "documentation": {}
    },
    {
        "label": "map_filter_value",
        "importPath": "filter_mapping",
        "description": "filter_mapping",
        "isExtraImport": true,
        "detail": "filter_mapping",
        "documentation": {}
    },
    {
        "label": "BRAND_SYNONYMS",
        "importPath": "brand_synonyms",
        "description": "brand_synonyms",
        "isExtraImport": true,
        "detail": "brand_synonyms",
        "documentation": {}
    },
    {
        "label": "BRAND_SYNONYMS",
        "importPath": "brand_synonyms",
        "description": "brand_synonyms",
        "isExtraImport": true,
        "detail": "brand_synonyms",
        "documentation": {}
    },
    {
        "label": "OTECHESTVENNYE",
        "importPath": "brand_synonyms",
        "description": "brand_synonyms",
        "isExtraImport": true,
        "detail": "brand_synonyms",
        "documentation": {}
    },
    {
        "label": "MODEL_SYNONYMS",
        "importPath": "brand_synonyms",
        "description": "brand_synonyms",
        "isExtraImport": true,
        "detail": "brand_synonyms",
        "documentation": {}
    },
    {
        "label": "BRAND_SYNONYMS",
        "importPath": "brand_synonyms",
        "description": "brand_synonyms",
        "isExtraImport": true,
        "detail": "brand_synonyms",
        "documentation": {}
    },
    {
        "label": "CHINESE_MODEL_SYNONYMS",
        "importPath": "brand_synonyms",
        "description": "brand_synonyms",
        "isExtraImport": true,
        "detail": "brand_synonyms",
        "documentation": {}
    },
    {
        "label": "OTECHESTVENNYE",
        "importPath": "brand_synonyms",
        "description": "brand_synonyms",
        "isExtraImport": true,
        "detail": "brand_synonyms",
        "documentation": {}
    },
    {
        "label": "normalize_brand_extended",
        "importPath": "brand_synonyms",
        "description": "brand_synonyms",
        "isExtraImport": true,
        "detail": "brand_synonyms",
        "documentation": {}
    },
    {
        "label": "get_all_brand_variants",
        "importPath": "brand_synonyms",
        "description": "brand_synonyms",
        "isExtraImport": true,
        "detail": "brand_synonyms",
        "documentation": {}
    },
    {
        "label": "find_similar_brands",
        "importPath": "brand_synonyms",
        "description": "brand_synonyms",
        "isExtraImport": true,
        "detail": "brand_synonyms",
        "documentation": {}
    },
    {
        "label": "normalize_brand_extended",
        "importPath": "brand_synonyms",
        "description": "brand_synonyms",
        "isExtraImport": true,
        "detail": "brand_synonyms",
        "documentation": {}
    },
    {
        "label": "get_all_brand_variants",
        "importPath": "brand_synonyms",
        "description": "brand_synonyms",
        "isExtraImport": true,
        "detail": "brand_synonyms",
        "documentation": {}
    },
    {
        "label": "CHINESE_MODEL_SYNONYMS",
        "importPath": "brand_synonyms",
        "description": "brand_synonyms",
        "isExtraImport": true,
        "detail": "brand_synonyms",
        "documentation": {}
    },
    {
        "label": "CHINESE_MODEL_SYNONYMS",
        "importPath": "brand_synonyms",
        "description": "brand_synonyms",
        "isExtraImport": true,
        "detail": "brand_synonyms",
        "documentation": {}
    },
    {
        "label": "generate_with_llama",
        "importPath": "llama_service",
        "description": "llama_service",
        "isExtraImport": true,
        "detail": "llama_service",
        "documentation": {}
    },
    {
        "label": "deepseek_service",
        "importPath": "deepseek_service",
        "description": "deepseek_service",
        "isExtraImport": true,
        "detail": "deepseek_service",
        "documentation": {}
    },
    {
        "label": "system_monitor",
        "importPath": "monitoring",
        "description": "monitoring",
        "isExtraImport": true,
        "detail": "monitoring",
        "documentation": {}
    },
    {
        "label": "SystemMonitor",
        "importPath": "monitoring",
        "description": "monitoring",
        "isExtraImport": true,
        "detail": "monitoring",
        "documentation": {}
    },
    {
        "label": "IntelligentQueryProcessor",
        "importPath": "intelligent_query_processor",
        "description": "intelligent_query_processor",
        "isExtraImport": true,
        "detail": "intelligent_query_processor",
        "documentation": {}
    },
    {
        "label": "IntelligentQueryProcessor",
        "importPath": "intelligent_query_processor",
        "description": "intelligent_query_processor",
        "isExtraImport": true,
        "detail": "intelligent_query_processor",
        "documentation": {}
    },
    {
        "label": "IntelligentQueryProcessor",
        "importPath": "intelligent_query_processor",
        "description": "intelligent_query_processor",
        "isExtraImport": true,
        "detail": "intelligent_query_processor",
        "documentation": {}
    },
    {
        "label": "IntelligentQueryProcessor",
        "importPath": "intelligent_query_processor",
        "description": "intelligent_query_processor",
        "isExtraImport": true,
        "detail": "intelligent_query_processor",
        "documentation": {}
    },
    {
        "label": "IntelligentQueryProcessor",
        "importPath": "intelligent_query_processor",
        "description": "intelligent_query_processor",
        "isExtraImport": true,
        "detail": "intelligent_query_processor",
        "documentation": {}
    },
    {
        "label": "IntelligentQueryProcessor",
        "importPath": "intelligent_query_processor",
        "description": "intelligent_query_processor",
        "isExtraImport": true,
        "detail": "intelligent_query_processor",
        "documentation": {}
    },
    {
        "label": "IntelligentQueryProcessor",
        "importPath": "intelligent_query_processor",
        "description": "intelligent_query_processor",
        "isExtraImport": true,
        "detail": "intelligent_query_processor",
        "documentation": {}
    },
    {
        "label": "IntelligentQueryProcessor",
        "importPath": "intelligent_query_processor",
        "description": "intelligent_query_processor",
        "isExtraImport": true,
        "detail": "intelligent_query_processor",
        "documentation": {}
    },
    {
        "label": "IntelligentQueryProcessor",
        "importPath": "intelligent_query_processor",
        "description": "intelligent_query_processor",
        "isExtraImport": true,
        "detail": "intelligent_query_processor",
        "documentation": {}
    },
    {
        "label": "IntelligentQueryProcessor",
        "importPath": "intelligent_query_processor",
        "description": "intelligent_query_processor",
        "isExtraImport": true,
        "detail": "intelligent_query_processor",
        "documentation": {}
    },
    {
        "label": "IntelligentQueryProcessor",
        "importPath": "intelligent_query_processor",
        "description": "intelligent_query_processor",
        "isExtraImport": true,
        "detail": "intelligent_query_processor",
        "documentation": {}
    },
    {
        "label": "IntelligentQueryProcessor",
        "importPath": "intelligent_query_processor",
        "description": "intelligent_query_processor",
        "isExtraImport": true,
        "detail": "intelligent_query_processor",
        "documentation": {}
    },
    {
        "label": "RecommendationEngine",
        "importPath": "recommendation_engine",
        "description": "recommendation_engine",
        "isExtraImport": true,
        "detail": "recommendation_engine",
        "documentation": {}
    },
    {
        "label": "RecommendationEngine",
        "importPath": "recommendation_engine",
        "description": "recommendation_engine",
        "isExtraImport": true,
        "detail": "recommendation_engine",
        "documentation": {}
    },
    {
        "label": "UserAnalytics",
        "importPath": "user_analytics",
        "description": "user_analytics",
        "isExtraImport": true,
        "detail": "user_analytics",
        "documentation": {}
    },
    {
        "label": "UserAnalytics",
        "importPath": "user_analytics",
        "description": "user_analytics",
        "isExtraImport": true,
        "detail": "user_analytics",
        "documentation": {}
    },
    {
        "label": "NotificationSystem",
        "importPath": "notification_system",
        "description": "notification_system",
        "isExtraImport": true,
        "detail": "notification_system",
        "documentation": {}
    },
    {
        "label": "car_parser",
        "importPath": "car_parser",
        "description": "car_parser",
        "isExtraImport": true,
        "detail": "car_parser",
        "documentation": {}
    },
    {
        "label": "CarParser",
        "importPath": "car_parser",
        "description": "car_parser",
        "isExtraImport": true,
        "detail": "car_parser",
        "documentation": {}
    },
    {
        "label": "difflib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "difflib",
        "description": "difflib",
        "detail": "difflib",
        "documentation": {}
    },
    {
        "label": "get_close_matches",
        "importPath": "difflib",
        "description": "difflib",
        "isExtraImport": true,
        "detail": "difflib",
        "documentation": {}
    },
    {
        "label": "get_close_matches",
        "importPath": "difflib",
        "description": "difflib",
        "isExtraImport": true,
        "detail": "difflib",
        "documentation": {}
    },
    {
        "label": "get_close_matches",
        "importPath": "difflib",
        "description": "difflib",
        "isExtraImport": true,
        "detail": "difflib",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "wraps",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "requests",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "requests",
        "description": "requests",
        "detail": "requests",
        "documentation": {}
    },
    {
        "label": "BeautifulSoup",
        "importPath": "bs4",
        "description": "bs4",
        "isExtraImport": true,
        "detail": "bs4",
        "documentation": {}
    },
    {
        "label": "urljoin",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "urlparse",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "importlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "importlib",
        "description": "importlib",
        "detail": "importlib",
        "documentation": {}
    },
    {
        "label": "contextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "redis",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "redis",
        "description": "redis",
        "detail": "redis",
        "documentation": {}
    },
    {
        "label": "hashlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "hashlib",
        "description": "hashlib",
        "detail": "hashlib",
        "documentation": {}
    },
    {
        "label": "inspect",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "inspect",
        "description": "inspect",
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "unicodedata",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "unicodedata",
        "description": "unicodedata",
        "detail": "unicodedata",
        "documentation": {}
    },
    {
        "label": "threading",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading",
        "description": "threading",
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "escape",
        "importPath": "html",
        "description": "html",
        "isExtraImport": true,
        "detail": "html",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "pprint",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pprint",
        "description": "pprint",
        "detail": "pprint",
        "documentation": {}
    },
    {
        "label": "LLAMA_API_URL",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "LLAMA_API_KEY",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "psutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "psutil",
        "description": "psutil",
        "detail": "psutil",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "smtplib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "smtplib",
        "description": "smtplib",
        "detail": "smtplib",
        "documentation": {}
    },
    {
        "label": "MIMEText",
        "importPath": "email.mime.text",
        "description": "email.mime.text",
        "isExtraImport": true,
        "detail": "email.mime.text",
        "documentation": {}
    },
    {
        "label": "MIMEMultipart",
        "importPath": "email.mime.multipart",
        "description": "email.mime.multipart",
        "isExtraImport": true,
        "detail": "email.mime.multipart",
        "documentation": {}
    },
    {
        "label": "signal",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "signal",
        "description": "signal",
        "detail": "signal",
        "documentation": {}
    },
    {
        "label": "unittest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "unittest",
        "description": "unittest",
        "detail": "unittest",
        "documentation": {}
    },
    {
        "label": "statistics",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "statistics",
        "description": "statistics",
        "detail": "statistics",
        "documentation": {}
    },
    {
        "label": "extract_file",
        "kind": 2,
        "importPath": ".venv.Scripts.vba_extract",
        "description": ".venv.Scripts.vba_extract",
        "peekOfCode": "def extract_file(xlsm_zip, filename):\n    # Extract a single file from an Excel xlsm macro file.\n    data = xlsm_zip.read(\"xl/\" + filename)\n    # Write the data to a local file.\n    file = open(filename, \"wb\")\n    file.write(data)\n    file.close()\n# The VBA project file and project signature file we want to extract.\nvba_filename = \"vbaProject.bin\"\nvba_signature_filename = \"vbaProjectSignature.bin\"",
        "detail": ".venv.Scripts.vba_extract",
        "documentation": {}
    },
    {
        "label": "vba_filename",
        "kind": 5,
        "importPath": ".venv.Scripts.vba_extract",
        "description": ".venv.Scripts.vba_extract",
        "peekOfCode": "vba_filename = \"vbaProject.bin\"\nvba_signature_filename = \"vbaProjectSignature.bin\"\n# Get the xlsm file name from the commandline.\nif len(sys.argv) > 1:\n    xlsm_file = sys.argv[1]\nelse:\n    print(\n        \"\\nUtility to extract a vbaProject.bin binary from an Excel 2007+ \"\n        \"xlsm macro file for insertion into an XlsxWriter file.\\n\"\n        \"If the macros are digitally signed, extracts also a vbaProjectSignature.bin \"",
        "detail": ".venv.Scripts.vba_extract",
        "documentation": {}
    },
    {
        "label": "vba_signature_filename",
        "kind": 5,
        "importPath": ".venv.Scripts.vba_extract",
        "description": ".venv.Scripts.vba_extract",
        "peekOfCode": "vba_signature_filename = \"vbaProjectSignature.bin\"\n# Get the xlsm file name from the commandline.\nif len(sys.argv) > 1:\n    xlsm_file = sys.argv[1]\nelse:\n    print(\n        \"\\nUtility to extract a vbaProject.bin binary from an Excel 2007+ \"\n        \"xlsm macro file for insertion into an XlsxWriter file.\\n\"\n        \"If the macros are digitally signed, extracts also a vbaProjectSignature.bin \"\n        \"file.\\n\"",
        "detail": ".venv.Scripts.vba_extract",
        "documentation": {}
    },
    {
        "label": "analyze_table",
        "kind": 2,
        "importPath": "analyze_user_data",
        "description": "analyze_user_data",
        "peekOfCode": "def analyze_table(table, limit=5):\n    conn = sqlite3.connect(DB_PATH)\n    cursor = conn.cursor()\n    cursor.execute(f'SELECT COUNT(*) FROM {table}')\n    count = cursor.fetchone()[0]\n    print(f'Таблица {table}: {count} записей')\n    if count > 0:\n        cursor.execute(f'SELECT * FROM {table} LIMIT {limit}')\n        rows = cursor.fetchall()\n        col_names = [desc[0] for desc in cursor.description]",
        "detail": "analyze_user_data",
        "documentation": {}
    },
    {
        "label": "dump_table",
        "kind": 2,
        "importPath": "analyze_user_data",
        "description": "analyze_user_data",
        "peekOfCode": "def dump_table(table, limit=100):\n    conn = sqlite3.connect(DB_PATH)\n    cursor = conn.cursor()\n    cursor.execute(f'SELECT COUNT(*) FROM {table}')\n    count = cursor.fetchone()[0]\n    print(f'Таблица {table}: {count} записей')\n    if count > 0:\n        cursor.execute(f'SELECT * FROM {table} LIMIT {limit}')\n        rows = cursor.fetchall()\n        col_names = [desc[0] for desc in cursor.description]",
        "detail": "analyze_user_data",
        "documentation": {}
    },
    {
        "label": "dump_uniques",
        "kind": 2,
        "importPath": "analyze_user_data",
        "description": "analyze_user_data",
        "peekOfCode": "def dump_uniques(table):\n    conn = sqlite3.connect(DB_PATH)\n    cursor = conn.cursor()\n    cursor.execute(f'PRAGMA table_info({table})')\n    columns = [row[1] for row in cursor.fetchall()]\n    print(f'Уникальные значения для таблицы {table}:')\n    for col in columns:\n        try:\n            cursor.execute(f'SELECT DISTINCT {col} FROM {table}')\n            values = sorted(set(str(row[0]) for row in cursor.fetchall() if row[0] is not None))",
        "detail": "analyze_user_data",
        "documentation": {}
    },
    {
        "label": "DB_PATH",
        "kind": 5,
        "importPath": "analyze_user_data",
        "description": "analyze_user_data",
        "peekOfCode": "DB_PATH = 'instance/cars.db'\ndef analyze_table(table, limit=5):\n    conn = sqlite3.connect(DB_PATH)\n    cursor = conn.cursor()\n    cursor.execute(f'SELECT COUNT(*) FROM {table}')\n    count = cursor.fetchone()[0]\n    print(f'Таблица {table}: {count} записей')\n    if count > 0:\n        cursor.execute(f'SELECT * FROM {table} LIMIT {limit}')\n        rows = cursor.fetchall()",
        "detail": "analyze_user_data",
        "documentation": {}
    },
    {
        "label": "ChatRequest",
        "kind": 6,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "class ChatRequest(BaseModel):\n    message: str\n    user_id: Optional[str] = \"default\"\n    use_deepseek: Optional[bool] = False  # Новый параметр для режима размышления\nclass SearchRequest(BaseModel):\n    brand: Optional[str] = None\n    model: Optional[str] = None\n    year_from: Optional[int] = None\n    year_to: Optional[int] = None\n    price_from: Optional[float] = None",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "SearchRequest",
        "kind": 6,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "class SearchRequest(BaseModel):\n    brand: Optional[str] = None\n    model: Optional[str] = None\n    year_from: Optional[int] = None\n    year_to: Optional[int] = None\n    price_from: Optional[float] = None\n    price_to: Optional[float] = None\n    fuel_type: Optional[str] = None\n    transmission: Optional[str] = None\n    body_type: Optional[str] = None",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "CompareRequest",
        "kind": 6,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "class CompareRequest(BaseModel):\n    car1_id: int\n    car2_id: int\nclass RecommendationRequest(BaseModel):\n    user_id: str\n    preferences: Optional[Dict[str, Any]] = None\n    budget: Optional[float] = None\n    purpose: Optional[str] = None  # family, sport, business, etc.\nclass TestDriveRequest(BaseModel):\n    user_id: str",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "RecommendationRequest",
        "kind": 6,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "class RecommendationRequest(BaseModel):\n    user_id: str\n    preferences: Optional[Dict[str, Any]] = None\n    budget: Optional[float] = None\n    purpose: Optional[str] = None  # family, sport, business, etc.\nclass TestDriveRequest(BaseModel):\n    user_id: str\n    car_id: int\n    preferred_date: str\n    preferred_time: str",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "TestDriveRequest",
        "kind": 6,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "class TestDriveRequest(BaseModel):\n    user_id: str\n    car_id: int\n    preferred_date: str\n    preferred_time: str\n    contact_phone: str\nclass CreditRequest(BaseModel):\n    user_id: str\n    car_id: int\n    down_payment: float",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "CreditRequest",
        "kind": 6,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "class CreditRequest(BaseModel):\n    user_id: str\n    car_id: int\n    down_payment: float\n    term_months: int\n    monthly_income: float\nclass ApplyFilterRequest(BaseModel):\n    user_id: str\n    filter_name: Optional[str] = None\n    filter_id: Optional[int] = None",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "ApplyFilterRequest",
        "kind": 6,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "class ApplyFilterRequest(BaseModel):\n    user_id: str\n    filter_name: Optional[str] = None\n    filter_id: Optional[int] = None\nclass LlamaRequest(BaseModel):\n    query: str\n    context: Optional[dict] = None\nclass LlamaFeedbackRequest(BaseModel):\n    user_id: str\n    query: str",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "LlamaRequest",
        "kind": 6,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "class LlamaRequest(BaseModel):\n    query: str\n    context: Optional[dict] = None\nclass LlamaFeedbackRequest(BaseModel):\n    user_id: str\n    query: str\n    llama_response: str\n    quality_score: int  # 1-5\n    comment: str = \"\"\nclass CarCreateRequest(BaseModel):",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "LlamaFeedbackRequest",
        "kind": 6,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "class LlamaFeedbackRequest(BaseModel):\n    user_id: str\n    query: str\n    llama_response: str\n    quality_score: int  # 1-5\n    comment: str = \"\"\nclass CarCreateRequest(BaseModel):\n    mark: str\n    model: str\n    price: float",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "CarCreateRequest",
        "kind": 6,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "class CarCreateRequest(BaseModel):\n    mark: str\n    model: str\n    price: float\n    city: str\n    manufacture_year: int\n    fuel_type: str = ''\n    body_type: str = ''\n    gear_box_type: str = ''\n    driving_gear_type: str = ''",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "DealerCreateRequest",
        "kind": 6,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "class DealerCreateRequest(BaseModel):\n    name: str\n    address: str\n    phone: str = ''\n    email: str = ''\n    website: str = ''\n    latitude: float = 0.0\n    longitude: float = 0.0\n    brands: str = ''\nclass NotificationRequest(BaseModel):",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "NotificationRequest",
        "kind": 6,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "class NotificationRequest(BaseModel):\n    user_id: str\n    notification_type: str\n    title: str\n    message: str\n    priority: int = 1\n    action_url: Optional[str] = None\n    action_text: Optional[str] = None\n    expires_at: Optional[str] = None\n    metadata: Optional[Dict[str, Any]] = None",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "NotificationSettingsRequest",
        "kind": 6,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "class NotificationSettingsRequest(BaseModel):\n    user_id: str\n    email_notifications: bool = True\n    push_notifications: bool = True\n    recommendation_notifications: bool = True\n    system_alerts: bool = True\n    promotion_notifications: bool = True\n    notification_frequency: str = \"daily\"\n    quiet_hours_start: str = \"22:00\"\n    quiet_hours_end: str = \"08:00\"",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "UserBehaviorRequest",
        "kind": 6,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "class UserBehaviorRequest(BaseModel):\n    user_id: str\n    days: int = 30\nclass SystemAlertRequest(BaseModel):\n    alert_type: str\n    severity: str\n    title: str\n    description: str\n    metadata: Optional[Dict[str, Any]] = None\nclass CarParseRequest(BaseModel):",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "SystemAlertRequest",
        "kind": 6,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "class SystemAlertRequest(BaseModel):\n    alert_type: str\n    severity: str\n    title: str\n    description: str\n    metadata: Optional[Dict[str, Any]] = None\nclass CarParseRequest(BaseModel):\n    brand: str\n    model: str\n    price: int",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "CarParseRequest",
        "kind": 6,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "class CarParseRequest(BaseModel):\n    brand: str\n    model: str\n    price: int\n    city: Optional[str] = None\n    tolerance: Optional[float] = 0.1\nclass CarLinkRequest(BaseModel):\n    brand: str\n    model: str\n    city: Optional[str] = None",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "CarLinkRequest",
        "kind": 6,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "class CarLinkRequest(BaseModel):\n    brand: str\n    model: str\n    city: Optional[str] = None\nclass CarParseResponse(BaseModel):\n    success: bool\n    url: Optional[str] = None\n    brand: Optional[str] = None\n    model: Optional[str] = None\n    price: Optional[int] = None",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "CarParseResponse",
        "kind": 6,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "class CarParseResponse(BaseModel):\n    success: bool\n    url: Optional[str] = None\n    brand: Optional[str] = None\n    model: Optional[str] = None\n    price: Optional[int] = None\n    found_price: Optional[int] = None\n    price_difference: Optional[int] = None\n    title: Optional[str] = None\n    tech_info: Optional[Dict[str, str]] = None",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "check_api_key",
        "kind": 2,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "def check_api_key(x_api_key: str = Header(...)):\n    if x_api_key != API_KEY:\n        raise HTTPException(status_code=HTTP_401_UNAUTHORIZED, detail=\"Invalid API Key\")\n# --- Rate limiting ---\ndef rate_limiter(endpoint: str, user_id: str = 'anon'):\n    now = int(time.time() // 60)\n    key = f\"{endpoint}:{user_id}:{now}\"\n    count = rate_limit_state.get(key, 0)\n    if count >= RATE_LIMIT:\n        raise HTTPException(status_code=429, detail=\"Rate limit exceeded\")",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "rate_limiter",
        "kind": 2,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "def rate_limiter(endpoint: str, user_id: str = 'anon'):\n    now = int(time.time() // 60)\n    key = f\"{endpoint}:{user_id}:{now}\"\n    count = rate_limit_state.get(key, 0)\n    if count >= RATE_LIMIT:\n        raise HTTPException(status_code=429, detail=\"Rate limit exceeded\")\n    rate_limit_state[key] = count + 1\ndef get_cars_count() -> int:\n    \"\"\"Получение количества автомобилей\"\"\"\n    result1 = execute_query(\"SELECT COUNT(*) FROM car\")",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "get_cars_count",
        "kind": 2,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "def get_cars_count() -> int:\n    \"\"\"Получение количества автомобилей\"\"\"\n    result1 = execute_query(\"SELECT COUNT(*) FROM car\")\n    result2 = execute_query(\"SELECT COUNT(*) FROM used_car\")\n    return (result1[0][0] if result1 else 0) + (result2[0][0] if result2 else 0)\ndef get_car_by_id(car_id: int) -> Optional[dict]:\n    \"\"\"Получение автомобиля по ID\"\"\"\n    columns = [\n        \"id\", \"title\", \"doc_num\", \"mark\", \"model\", \"vin\", \"color\", \"price\", \"city\", \"manufacture_year\", \"body_type\", \"gear_box_type\", \"driving_gear_type\", \"engine_vol\", \"power\", \"fuel_type\", \"dealer_center\"\n    ]",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "get_car_by_id",
        "kind": 2,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "def get_car_by_id(car_id: int) -> Optional[dict]:\n    \"\"\"Получение автомобиля по ID\"\"\"\n    columns = [\n        \"id\", \"title\", \"doc_num\", \"mark\", \"model\", \"vin\", \"color\", \"price\", \"city\", \"manufacture_year\", \"body_type\", \"gear_box_type\", \"driving_gear_type\", \"engine_vol\", \"power\", \"fuel_type\", \"dealer_center\"\n    ]\n    car = execute_query(\"SELECT id, title, doc_num, mark, model, vin, color, price, city, manufacture_year, body_type, gear_box_type, driving_gear_type, engine_vol, power, fuel_type, dealer_center FROM car WHERE id = ?\", [car_id])\n    if car:\n        car_dict = dict(zip(columns, car[0]))\n        extras = execute_query(\"SELECT stock_qty, code_compl FROM car WHERE id = ?\", [car_id])\n        if extras:",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "initialize_database",
        "kind": 2,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "def initialize_database():\n    \"\"\"Инициализация базы данных\"\"\"\n    # Создание таблицы автомобилей если не существует (с существующей структурой)\n    execute_query(\"\"\"\n        CREATE TABLE IF NOT EXISTS car (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            title VARCHAR(100),\n            doc_num VARCHAR(50),\n            stock_qty INTEGER,\n            mark VARCHAR(100),",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "get_first_deep",
        "kind": 2,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "def get_first_deep(val):\n    if isinstance(val, (list, tuple)):\n        return get_first_deep(val[0]) if val else None\n    return val\ndef normalize_brand(value):\n    value = get_first_deep(value)\n    if not value:\n        return value\n    if not isinstance(value, str):\n        value = str(value)",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "normalize_brand",
        "kind": 2,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "def normalize_brand(value):\n    value = get_first_deep(value)\n    if not value:\n        return value\n    if not isinstance(value, str):\n        value = str(value)\n    brands = get_all_brands_cached()\n    for b in brands:\n        if isinstance(b, tuple):\n            b = b[0]",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "normalize_model",
        "kind": 2,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "def normalize_model(value):\n    value = get_first_deep(value)\n    if not value:\n        return value\n    if not isinstance(value, str):\n        value = str(value)\n    models = get_all_models_cached()\n    for m in models:\n        if isinstance(m, tuple):\n            m = m[0]",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "bulk_delete_cars",
        "kind": 2,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "def bulk_delete_cars():\n    data = request.get_json()\n    ids = data.get('ids', [])\n    if not ids:\n        return {'success': False, 'error': 'No ids provided'}, 400\n    try:\n        from database import delete_cars_by_ids\n        deleted = delete_cars_by_ids(ids)\n        return {'success': True, 'deleted': deleted}\n    except Exception as e:",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "logger = logging.getLogger(__name__)\napp = FastAPI(title=\"Автоассистент API\", version=\"2.0.0\")\n# Добавление CORS middleware\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "app = FastAPI(title=\"Автоассистент API\", version=\"2.0.0\")\n# Добавление CORS middleware\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n# Монтирование статических файлов",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "USE_CONTEXT_MANAGER",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "USE_CONTEXT_MANAGER = True  # Флаг для включения контекстного менеджера\ndialog_manager = DialogManager()\ncontext_dialog_manager = ContextAwareDialogManager()\nnlp_processor = NLPProcessor()\nfuzzy_search = FuzzySearch()\nuser_history_manager = UserHistory()\nnlp = NLPProcessor()\nprocessor = IntelligentQueryProcessor(nlp)\nrecommendation_engine = RecommendationEngine()\nuser_analytics = UserAnalytics()",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "dialog_manager",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "dialog_manager = DialogManager()\ncontext_dialog_manager = ContextAwareDialogManager()\nnlp_processor = NLPProcessor()\nfuzzy_search = FuzzySearch()\nuser_history_manager = UserHistory()\nnlp = NLPProcessor()\nprocessor = IntelligentQueryProcessor(nlp)\nrecommendation_engine = RecommendationEngine()\nuser_analytics = UserAnalytics()\nnotification_system = NotificationSystem()",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "context_dialog_manager",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "context_dialog_manager = ContextAwareDialogManager()\nnlp_processor = NLPProcessor()\nfuzzy_search = FuzzySearch()\nuser_history_manager = UserHistory()\nnlp = NLPProcessor()\nprocessor = IntelligentQueryProcessor(nlp)\nrecommendation_engine = RecommendationEngine()\nuser_analytics = UserAnalytics()\nnotification_system = NotificationSystem()\n# Модели данных",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "nlp_processor",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "nlp_processor = NLPProcessor()\nfuzzy_search = FuzzySearch()\nuser_history_manager = UserHistory()\nnlp = NLPProcessor()\nprocessor = IntelligentQueryProcessor(nlp)\nrecommendation_engine = RecommendationEngine()\nuser_analytics = UserAnalytics()\nnotification_system = NotificationSystem()\n# Модели данных\nclass ChatRequest(BaseModel):",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "fuzzy_search",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "fuzzy_search = FuzzySearch()\nuser_history_manager = UserHistory()\nnlp = NLPProcessor()\nprocessor = IntelligentQueryProcessor(nlp)\nrecommendation_engine = RecommendationEngine()\nuser_analytics = UserAnalytics()\nnotification_system = NotificationSystem()\n# Модели данных\nclass ChatRequest(BaseModel):\n    message: str",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "user_history_manager",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "user_history_manager = UserHistory()\nnlp = NLPProcessor()\nprocessor = IntelligentQueryProcessor(nlp)\nrecommendation_engine = RecommendationEngine()\nuser_analytics = UserAnalytics()\nnotification_system = NotificationSystem()\n# Модели данных\nclass ChatRequest(BaseModel):\n    message: str\n    user_id: Optional[str] = \"default\"",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "nlp",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "nlp = NLPProcessor()\nprocessor = IntelligentQueryProcessor(nlp)\nrecommendation_engine = RecommendationEngine()\nuser_analytics = UserAnalytics()\nnotification_system = NotificationSystem()\n# Модели данных\nclass ChatRequest(BaseModel):\n    message: str\n    user_id: Optional[str] = \"default\"\n    use_deepseek: Optional[bool] = False  # Новый параметр для режима размышления",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "processor",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "processor = IntelligentQueryProcessor(nlp)\nrecommendation_engine = RecommendationEngine()\nuser_analytics = UserAnalytics()\nnotification_system = NotificationSystem()\n# Модели данных\nclass ChatRequest(BaseModel):\n    message: str\n    user_id: Optional[str] = \"default\"\n    use_deepseek: Optional[bool] = False  # Новый параметр для режима размышления\nclass SearchRequest(BaseModel):",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "recommendation_engine",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "recommendation_engine = RecommendationEngine()\nuser_analytics = UserAnalytics()\nnotification_system = NotificationSystem()\n# Модели данных\nclass ChatRequest(BaseModel):\n    message: str\n    user_id: Optional[str] = \"default\"\n    use_deepseek: Optional[bool] = False  # Новый параметр для режима размышления\nclass SearchRequest(BaseModel):\n    brand: Optional[str] = None",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "user_analytics",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "user_analytics = UserAnalytics()\nnotification_system = NotificationSystem()\n# Модели данных\nclass ChatRequest(BaseModel):\n    message: str\n    user_id: Optional[str] = \"default\"\n    use_deepseek: Optional[bool] = False  # Новый параметр для режима размышления\nclass SearchRequest(BaseModel):\n    brand: Optional[str] = None\n    model: Optional[str] = None",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "notification_system",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "notification_system = NotificationSystem()\n# Модели данных\nclass ChatRequest(BaseModel):\n    message: str\n    user_id: Optional[str] = \"default\"\n    use_deepseek: Optional[bool] = False  # Новый параметр для режима размышления\nclass SearchRequest(BaseModel):\n    brand: Optional[str] = None\n    model: Optional[str] = None\n    year_from: Optional[int] = None",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "API_KEY",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "API_KEY = os.environ.get('API_KEY', 'supersecret')\nRATE_LIMIT = 30  # запросов в минуту на эндпоинт\nrate_limit_state = {}\ndef check_api_key(x_api_key: str = Header(...)):\n    if x_api_key != API_KEY:\n        raise HTTPException(status_code=HTTP_401_UNAUTHORIZED, detail=\"Invalid API Key\")\n# --- Rate limiting ---\ndef rate_limiter(endpoint: str, user_id: str = 'anon'):\n    now = int(time.time() // 60)\n    key = f\"{endpoint}:{user_id}:{now}\"",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "RATE_LIMIT",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "RATE_LIMIT = 30  # запросов в минуту на эндпоинт\nrate_limit_state = {}\ndef check_api_key(x_api_key: str = Header(...)):\n    if x_api_key != API_KEY:\n        raise HTTPException(status_code=HTTP_401_UNAUTHORIZED, detail=\"Invalid API Key\")\n# --- Rate limiting ---\ndef rate_limiter(endpoint: str, user_id: str = 'anon'):\n    now = int(time.time() // 60)\n    key = f\"{endpoint}:{user_id}:{now}\"\n    count = rate_limit_state.get(key, 0)",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "rate_limit_state",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "rate_limit_state = {}\ndef check_api_key(x_api_key: str = Header(...)):\n    if x_api_key != API_KEY:\n        raise HTTPException(status_code=HTTP_401_UNAUTHORIZED, detail=\"Invalid API Key\")\n# --- Rate limiting ---\ndef rate_limiter(endpoint: str, user_id: str = 'anon'):\n    now = int(time.time() // 60)\n    key = f\"{endpoint}:{user_id}:{now}\"\n    count = rate_limit_state.get(key, 0)\n    if count >= RATE_LIMIT:",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "CSRF_TOKENS",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "CSRF_TOKENS = set()\n@app.get('/api/csrf-token')\nasync def get_csrf_token():\n    token = secrets.token_urlsafe(32)\n    CSRF_TOKENS.add(token)\n    return {\"token\": token}\n@app.middleware('http')\nasync def csrf_protect(request: Request, call_next):\n    # Временно отключаем CSRF защиту для тестирования\n    # if request.method in ('POST', 'PUT', 'DELETE'):",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "get_all_brands_from_db",
        "kind": 2,
        "importPath": "brand_synonyms",
        "description": "brand_synonyms",
        "peekOfCode": "def get_all_brands_from_db():\n    \"\"\"Получает все уникальные бренды из базы данных\"\"\"\n    db_path = os.path.join(os.path.dirname(__file__), 'instance', 'cars.db')\n    if not os.path.exists(db_path):\n        return set()\n    try:\n        with sqlite3.connect(db_path) as conn:\n            cursor = conn.cursor()\n            cursor.execute(\"\"\"\n                SELECT DISTINCT mark FROM car ",
        "detail": "brand_synonyms",
        "documentation": {}
    },
    {
        "label": "create_extended_brand_synonyms",
        "kind": 2,
        "importPath": "brand_synonyms",
        "description": "brand_synonyms",
        "peekOfCode": "def create_extended_brand_synonyms():\n    \"\"\"Создает расширенный словарь синонимов на основе данных из БД\"\"\"\n    db_brands = get_all_brands_from_db()\n    extended_synonyms = BRAND_SYNONYMS.copy()\n    # Группируем похожие бренды по каноническим названиям\n    brand_groups = {}\n    for brand in db_brands:\n        if not brand:\n            continue\n        brand_lower = brand.lower().strip()",
        "detail": "brand_synonyms",
        "documentation": {}
    },
    {
        "label": "determine_canonical_brand",
        "kind": 2,
        "importPath": "brand_synonyms",
        "description": "brand_synonyms",
        "peekOfCode": "def determine_canonical_brand(brand):\n    \"\"\"Определяет каноническое название бренда на основе различных правил\"\"\"\n    brand_lower = brand.lower().strip()\n    # Правила для определения канонического названия\n    canonical_rules = {\n        # Китайские бренды\n        'chery': 'Chery',\n        'geely': 'Geely',\n        'haval': 'Haval',\n        'byd': 'BYD',",
        "detail": "brand_synonyms",
        "documentation": {}
    },
    {
        "label": "get_all_brand_variants",
        "kind": 2,
        "importPath": "brand_synonyms",
        "description": "brand_synonyms",
        "peekOfCode": "def get_all_brand_variants(brand_input=None):\n    \"\"\"Получает все варианты брендов\"\"\"\n    db_path = os.path.join(os.path.dirname(__file__), 'instance', 'cars.db')\n    if not os.path.exists(db_path):\n        return set()\n    try:\n        with sqlite3.connect(db_path) as conn:\n            cursor = conn.cursor()\n            cursor.execute(\"\"\"\n                SELECT DISTINCT mark FROM car ",
        "detail": "brand_synonyms",
        "documentation": {}
    },
    {
        "label": "is_same_brand",
        "kind": 2,
        "importPath": "brand_synonyms",
        "description": "brand_synonyms",
        "peekOfCode": "def is_same_brand(brand1, brand2):\n    \"\"\"Проверяет, являются ли два бренда одним и тем же\"\"\"\n    brand1_lower = brand1.lower().strip()\n    brand2_lower = brand2.lower().strip()\n    # Прямое сравнение\n    if brand1_lower == brand2_lower:\n        return True\n    # Проверяем через канонические названия\n    canonical1 = determine_canonical_brand(brand1)\n    canonical2 = determine_canonical_brand(brand2)",
        "detail": "brand_synonyms",
        "documentation": {}
    },
    {
        "label": "find_similar_brands",
        "kind": 2,
        "importPath": "brand_synonyms",
        "description": "brand_synonyms",
        "peekOfCode": "def find_similar_brands(user_input, threshold=0.8):\n    \"\"\"Находит похожие бренды в базе данных с учетом несоответствий\"\"\"\n    user_input_lower = user_input.lower().strip()\n    # Сначала проверяем точное совпадение в словаре\n    if user_input_lower in BRAND_SYNONYMS:\n        canonical = BRAND_SYNONYMS[user_input_lower]\n        return get_all_brand_variants(canonical)\n    # Получаем все бренды из БД\n    db_brands = get_all_brands_from_db()\n    # Ищем похожие бренды",
        "detail": "brand_synonyms",
        "documentation": {}
    },
    {
        "label": "normalize_brand_extended",
        "kind": 2,
        "importPath": "brand_synonyms",
        "description": "brand_synonyms",
        "peekOfCode": "def normalize_brand_extended(brand_input):\n    \"\"\"Нормализует бренд с учетом всех возможных вариантов написания\"\"\"\n    if not brand_input:\n        return None\n    brand_input_lower = brand_input.lower().strip()\n    # Проверяем базовый словарь\n    if brand_input_lower in BRAND_SYNONYMS:\n        return BRAND_SYNONYMS[brand_input_lower]\n    # Получаем расширенный словарь\n    extended_synonyms = create_extended_brand_synonyms()",
        "detail": "brand_synonyms",
        "documentation": {}
    },
    {
        "label": "CHINESE_BRAND_SYNONYMS",
        "kind": 5,
        "importPath": "brand_synonyms",
        "description": "brand_synonyms",
        "peekOfCode": "CHINESE_BRAND_SYNONYMS = {\n    'chery': ['чери', 'чері', 'chery', 'черри'],\n    'exeed': ['эксид', 'эксиид', 'exeed', 'ексид'],\n    'omoda': ['омода', 'omoda'],\n    'jaecoo': ['джейку', 'джеку', 'jaecoo'],\n    'haval': ['хавейл', 'хавал', 'haval'],\n    'geely': ['джили', 'geely', 'гели'],\n    'changan': ['чанган', 'changan'],\n    'faw': ['фав', 'faw'],\n    'dongfeng': ['донгфенг', 'dongfeng'],",
        "detail": "brand_synonyms",
        "documentation": {}
    },
    {
        "label": "EUROPEAN_BRAND_SYNONYMS",
        "kind": 5,
        "importPath": "brand_synonyms",
        "description": "brand_synonyms",
        "peekOfCode": "EUROPEAN_BRAND_SYNONYMS = {\n    'bmw': ['бмв', 'bmw', 'беэмвэ'],\n    'mercedes-benz': ['мерседес', 'mercedes-benz', 'мерс'],\n    'audi': ['ауди', 'audi', 'ауды'],\n    'volkswagen': ['фольксваген', 'volkswagen', 'вв', 'vw'],\n    'skoda': ['шкода', 'skoda'],\n    'opel': ['опель', 'opel'],\n    'porsche': ['порше', 'porsche'],\n    'mini': ['мини', 'mini'],\n    'maybach': ['майбах', 'maybach'],",
        "detail": "brand_synonyms",
        "documentation": {}
    },
    {
        "label": "KOREAN_BRAND_SYNONYMS",
        "kind": 5,
        "importPath": "brand_synonyms",
        "description": "brand_synonyms",
        "peekOfCode": "KOREAN_BRAND_SYNONYMS = {\n    'kia': ['киа', 'kia', 'кия'],\n    'hyundai': ['хендай', 'hyundai', 'хундай', 'хендэ'],\n    'ssangyong': ['ссангйонг', 'ssangyong'],\n    'genesis': ['генесис', 'genesis'],\n}\n    # --- Японские бренды ---\nJAPANESE_BRAND_SYNONYMS = {\n    'toyota': ['тойота', 'toyota', 'тоёта', 'тойотта'],\n    'nissan': ['ниссан', 'nissan', 'нисан'],",
        "detail": "brand_synonyms",
        "documentation": {}
    },
    {
        "label": "JAPANESE_BRAND_SYNONYMS",
        "kind": 5,
        "importPath": "brand_synonyms",
        "description": "brand_synonyms",
        "peekOfCode": "JAPANESE_BRAND_SYNONYMS = {\n    'toyota': ['тойота', 'toyota', 'тоёта', 'тойотта'],\n    'nissan': ['ниссан', 'nissan', 'нисан'],\n    'honda': ['хонда', 'honda'],\n    'mazda': ['мазда', 'mazda'],\n    'lexus': ['лексус', 'lexus'],\n    'mitsubishi': ['мицубиси', 'mitsubishi', 'мицубиши'],\n    'subaru': ['субару', 'subaru'],\n    'suzuki': ['сузуки', 'suzuki'],\n    'infiniti': ['инфинити', 'infiniti'],",
        "detail": "brand_synonyms",
        "documentation": {}
    },
    {
        "label": "AMERICAN_BRAND_SYNONYMS",
        "kind": 5,
        "importPath": "brand_synonyms",
        "description": "brand_synonyms",
        "peekOfCode": "AMERICAN_BRAND_SYNONYMS = {\n    'ford': ['форд', 'ford'],\n    'chevrolet': ['шевроле', 'chevrolet'],\n    'jeep': ['джип', 'jeep'],\n    'dodge': ['додж', 'dodge'],\n    'chrysler': ['крайслер', 'chrysler'],\n    'cadillac': ['кадиллак', 'cadillac'],\n    'lincoln': ['линкольн', 'lincoln'],\n    'buick': ['бьюик', 'buick'],\n    'pontiac': ['понтиак', 'pontiac'],",
        "detail": "brand_synonyms",
        "documentation": {}
    },
    {
        "label": "SWEDISH_BRAND_SYNONYMS",
        "kind": 5,
        "importPath": "brand_synonyms",
        "description": "brand_synonyms",
        "peekOfCode": "SWEDISH_BRAND_SYNONYMS = {\n    'volvo': ['вольво', 'volvo'],\n    'saab': ['сааб', 'saab'],\n    'polestar': ['полестар', 'polestar'],\n}\n    # --- Британские бренды ---\nBRITISH_BRAND_SYNONYMS = {\n    'jaguar': ['ягуар', 'jaguar'],\n    'land rover': ['ленд ровер', 'land rover'],\n    'rolls-royce': ['роллс ройс', 'rolls-royce'],",
        "detail": "brand_synonyms",
        "documentation": {}
    },
    {
        "label": "BRITISH_BRAND_SYNONYMS",
        "kind": 5,
        "importPath": "brand_synonyms",
        "description": "brand_synonyms",
        "peekOfCode": "BRITISH_BRAND_SYNONYMS = {\n    'jaguar': ['ягуар', 'jaguar'],\n    'land rover': ['ленд ровер', 'land rover'],\n    'rolls-royce': ['роллс ройс', 'rolls-royce'],\n    'bentley': ['бентли', 'bentley'],\n    'aston martin': ['астон мартин', 'aston martin'],\n    'mclaren': ['макларен', 'mclaren', 'маклерен'],\n    'lotus': ['лотос', 'lotus'],\n    'canoo': ['кану', 'canoo'],\n}",
        "detail": "brand_synonyms",
        "documentation": {}
    },
    {
        "label": "RUSSIAN_BRAND_SYNONYMS",
        "kind": 5,
        "importPath": "brand_synonyms",
        "description": "brand_synonyms",
        "peekOfCode": "RUSSIAN_BRAND_SYNONYMS = {\n    'lada': ['лада', 'lada', 'ваз', 'жигули', 'лада (ваз)'],\n    'москвич': ['москвич', 'moskvich', 'moscvich'],\n    'уаз': ['уаз'],\n    'газ': ['газ'],\n    'камаз': ['камаз'],\n}\n    # --- Другие популярные бренды ---\nOTHER_BRAND_SYNONYMS = {\n    'faraday future': ['фарадей фьючер', 'faraday future'],",
        "detail": "brand_synonyms",
        "documentation": {}
    },
    {
        "label": "OTHER_BRAND_SYNONYMS",
        "kind": 5,
        "importPath": "brand_synonyms",
        "description": "brand_synonyms",
        "peekOfCode": "OTHER_BRAND_SYNONYMS = {\n    'faraday future': ['фарадей фьючер', 'faraday future'],\n    'fisker': ['фискер', 'fisker'],\n    'nikola': ['никола', 'nikola'],\n    'lordstown': ['лордстаун', 'lordstown'],\n    'koenigsegg': ['коенигсегг', 'koenigsegg'],\n    'bugatti': ['бугатти', 'bugatti'],\n}\n# --- Объединённый словарь для использования в коде ---\nBRAND_SYNONYMS = {}",
        "detail": "brand_synonyms",
        "documentation": {}
    },
    {
        "label": "BRAND_SYNONYMS",
        "kind": 5,
        "importPath": "brand_synonyms",
        "description": "brand_synonyms",
        "peekOfCode": "BRAND_SYNONYMS = {}\nfor d in (\n    EUROPEAN_BRAND_SYNONYMS,\n    CHINESE_BRAND_SYNONYMS,\n    KOREAN_BRAND_SYNONYMS,\n    JAPANESE_BRAND_SYNONYMS,\n    AMERICAN_BRAND_SYNONYMS,\n    SWEDISH_BRAND_SYNONYMS,\n    BRITISH_BRAND_SYNONYMS,\n    RUSSIAN_BRAND_SYNONYMS,",
        "detail": "brand_synonyms",
        "documentation": {}
    },
    {
        "label": "CHINESE_MODEL_SYNONYMS",
        "kind": 5,
        "importPath": "brand_synonyms",
        "description": "brand_synonyms",
        "peekOfCode": "CHINESE_MODEL_SYNONYMS = {\n    # Chery\n    'тигго': 'Tiggo', 'тиго': 'Tiggo', 'тигго': 'Tiggo',\n    'тигго 4': 'Tiggo 4', 'тигго 4 про': 'Tiggo 4 Pro', 'тигго 4 про': 'Tiggo 4 Pro',\n    'тигго 7': 'Tiggo 7', 'тигго 7 про': 'Tiggo 7 Pro', 'тигго 7 про макс': 'Tiggo 7 Pro Max',\n    'тиго 7': 'Tiggo 7', 'тиго 7 про': 'Tiggo 7 Pro', 'тиго 7 про макс': 'Tiggo 7 Pro Max',\n    'тиго макс 7 про': 'Tiggo 7 Pro Max', 'тиго макс 7': 'Tiggo 7 Pro Max',\n    'тигго макс 7 про': 'Tiggo 7 Pro Max', 'тигго макс 7': 'Tiggo 7 Pro Max',\n    'тигго 8': 'Tiggo 8', 'тигго 8 про': 'Tiggo 8 Pro', 'тигго 8 про макс': 'Tiggo 8 Pro Max', 'тигго 8 про е+': 'Tiggo 8 Pro e+',\n    'аризо': 'Arrizo', 'arrizo 8': 'Arrizo 8', 'аризо': 'Arrizo',",
        "detail": "brand_synonyms",
        "documentation": {}
    },
    {
        "label": "BMW_MODEL_SYNONYMS",
        "kind": 5,
        "importPath": "brand_synonyms",
        "description": "brand_synonyms",
        "peekOfCode": "BMW_MODEL_SYNONYMS = {\n    # X-серия\n    'x1': 'X1', 'х1': 'X1',\n    'x2': 'X2', 'х2': 'X2',\n    'x3': 'X3', 'х3': 'X3', 'x3 xdrive': 'X3 XDRIVE', 'x3 xdrive30l': 'X3 XDRIVE30L',\n    'x4': 'X4', 'х4': 'X4',\n    'x5': 'X5', 'х5': 'X5', 'x 5': 'X5', 'x-5': 'X5', 'xdrive': 'X5', 'x5 xdrive': 'X5 XDRIVE',\n    'x6': 'X6', 'х6': 'X6',\n    'x7': 'X7', 'х7': 'X7',\n    'xm': 'XM', 'хм': 'XM',",
        "detail": "brand_synonyms",
        "documentation": {}
    },
    {
        "label": "MERCEDES_MODEL_SYNONYMS",
        "kind": 5,
        "importPath": "brand_synonyms",
        "description": "brand_synonyms",
        "peekOfCode": "MERCEDES_MODEL_SYNONYMS = {\n    # A-класс\n    'a-класс': 'A-класс', 'a класс': 'A-класс', 'a class': 'A-класс', 'a200': 'A-класс', 'a180': 'A-класс',\n    # B-класс\n    'b-класс': 'B-класс', 'b класс': 'B-класс', 'b class': 'B-класс',\n    # C-класс\n    'c-класс': 'C-класс', 'c класс': 'C-класс', 'c class': 'C-класс', 'c200': 'C-класс', 'c180': 'C-класс',\n    # E-класс\n    'e-класс': 'E-класс', 'e класс': 'E-класс', 'e class': 'E-класс', 'e200': 'E-класс', 'e300': 'E-класс',\n    # S-класс",
        "detail": "brand_synonyms",
        "documentation": {}
    },
    {
        "label": "AUDI_MODEL_SYNONYMS",
        "kind": 5,
        "importPath": "brand_synonyms",
        "description": "brand_synonyms",
        "peekOfCode": "AUDI_MODEL_SYNONYMS = {\n    # A-серия\n    'a1': 'A1', 'а1': 'A1',\n    'a3': 'A3', 'а3': 'A3',\n    'a4': 'A4', 'а4': 'A4',\n    'a5': 'A5', 'а5': 'A5',\n    'a6': 'A6', 'а6': 'A6',\n    'a7': 'A7', 'а7': 'A7',\n    'a8': 'A8', 'а8': 'A8',\n    # Q-серия",
        "detail": "brand_synonyms",
        "documentation": {}
    },
    {
        "label": "VW_MODEL_SYNONYMS",
        "kind": 5,
        "importPath": "brand_synonyms",
        "description": "brand_synonyms",
        "peekOfCode": "VW_MODEL_SYNONYMS = {\n    # Golf серия\n    'golf': 'Golf', 'гольф': 'Golf', 'голф': 'Golf',\n    'golf gti': 'Golf GTI', 'гольф гти': 'Golf GTI',\n    'golf r': 'Golf R', 'гольф р': 'Golf R',\n    # Passat\n    'passat': 'Passat', 'пассат': 'Passat',\n    # Tiguan, Touareg\n    'tiguan': 'Tiguan', 'тигуан': 'Tiguan',\n    'touareg': 'Touareg', 'туарег': 'Touareg',",
        "detail": "brand_synonyms",
        "documentation": {}
    },
    {
        "label": "TOYOTA_MODEL_SYNONYMS",
        "kind": 5,
        "importPath": "brand_synonyms",
        "description": "brand_synonyms",
        "peekOfCode": "TOYOTA_MODEL_SYNONYMS = {\n    # Camry, Corolla\n    'camry': 'Camry', 'камри': 'Camry',\n    'corolla': 'Corolla', 'королла': 'Corolla',\n    # RAV4, Highlander\n    'rav4': 'RAV4', 'рав4': 'RAV4', 'рав 4': 'RAV4',\n    'highlander': 'Highlander', 'хайлендер': 'Highlander',\n    # Land Cruiser\n    'land cruiser': 'Land Cruiser', 'ленд крузер': 'Land Cruiser', 'ленд круизер': 'Land Cruiser',\n    'prado': 'Prado', 'прадо': 'Prado',",
        "detail": "brand_synonyms",
        "documentation": {}
    },
    {
        "label": "HONDA_MODEL_SYNONYMS",
        "kind": 5,
        "importPath": "brand_synonyms",
        "description": "brand_synonyms",
        "peekOfCode": "HONDA_MODEL_SYNONYMS = {\n    'civic': 'Civic', 'сивик': 'Civic',\n    'accord': 'Accord', 'аккорд': 'Accord',\n    'cr-v': 'CR-V', 'crv': 'CR-V', 'кр-в': 'CR-V', 'крв': 'CR-V',\n    'pilot': 'Pilot', 'пилот': 'Pilot',\n    'fit': 'Fit', 'фит': 'Fit',\n}\n# Словарь синонимов Mazda моделей\nMAZDA_MODEL_SYNONYMS = {\n    'cx-3': 'CX-3', 'cx3': 'CX-3', 'кс-3': 'CX-3', 'кс3': 'CX-3',",
        "detail": "brand_synonyms",
        "documentation": {}
    },
    {
        "label": "MAZDA_MODEL_SYNONYMS",
        "kind": 5,
        "importPath": "brand_synonyms",
        "description": "brand_synonyms",
        "peekOfCode": "MAZDA_MODEL_SYNONYMS = {\n    'cx-3': 'CX-3', 'cx3': 'CX-3', 'кс-3': 'CX-3', 'кс3': 'CX-3',\n    'cx-5': 'CX-5', 'cx5': 'CX-5', 'кс-5': 'CX-5', 'кс5': 'CX-5',\n    'cx-30': 'CX-30', 'cx30': 'CX-30', 'кс-30': 'CX-30', 'кс30': 'CX-30',\n    'cx-50': 'CX-50', 'cx50': 'CX-50', 'кс-50': 'CX-50', 'кс50': 'CX-50',\n    'cx-60': 'CX-60', 'cx60': 'CX-60', 'кс-60': 'CX-60', 'кс60': 'CX-60',\n    'cx-90': 'CX-90', 'cx90': 'CX-90', 'кс-90': 'CX-90', 'кс90': 'CX-90',\n    'mazda3': 'Mazda3', 'мазда3': 'Mazda3', 'мазда 3': 'Mazda3',\n    'mazda6': 'Mazda6', 'мазда6': 'Mazda6', 'мазда 6': 'Mazda6',\n}",
        "detail": "brand_synonyms",
        "documentation": {}
    },
    {
        "label": "LEXUS_MODEL_SYNONYMS",
        "kind": 5,
        "importPath": "brand_synonyms",
        "description": "brand_synonyms",
        "peekOfCode": "LEXUS_MODEL_SYNONYMS = {\n    'es': 'ES', 'ес': 'ES',\n    'is': 'IS', 'ис': 'IS',\n    'ls': 'LS', 'лс': 'LS',\n    'gs': 'GS', 'гс': 'GS',\n    'rx': 'RX', 'рх': 'RX',\n    'nx': 'NX', 'нх': 'NX',\n    'ux': 'UX', 'ух': 'UX',\n    'lx': 'LX', 'лх': 'LX',\n    'gx': 'GX', 'гх': 'GX',",
        "detail": "brand_synonyms",
        "documentation": {}
    },
    {
        "label": "KIA_MODEL_SYNONYMS",
        "kind": 5,
        "importPath": "brand_synonyms",
        "description": "brand_synonyms",
        "peekOfCode": "KIA_MODEL_SYNONYMS = {\n    'rio': 'Rio', 'рио': 'Rio',\n    'ceed': 'Ceed', 'сид': 'Ceed',\n    'sportage': 'Sportage', 'спортейдж': 'Sportage',\n    'sorento': 'Sorento', 'соренто': 'Sorento',\n    'cerato': 'Cerato', 'серато': 'Cerato',\n    'picanto': 'Picanto', 'пиканто': 'Picanto',\n    'stinger': 'Stinger', 'стингер': 'Stinger',\n    'ev6': 'EV6', 'ев6': 'EV6',\n}",
        "detail": "brand_synonyms",
        "documentation": {}
    },
    {
        "label": "HYUNDAI_MODEL_SYNONYMS",
        "kind": 5,
        "importPath": "brand_synonyms",
        "description": "brand_synonyms",
        "peekOfCode": "HYUNDAI_MODEL_SYNONYMS = {\n    'solaris': 'Solaris', 'солярис': 'Solaris',\n    'elantra': 'Elantra', 'элантра': 'Elantra',\n    'sonata': 'Sonata', 'соната': 'Sonata',\n    'tucson': 'Tucson', 'туссан': 'Tucson',\n    'santa fe': 'Santa Fe', 'санта фе': 'Santa Fe',\n    'palisade': 'Palisade', 'палисейд': 'Palisade',\n    'ioniq': 'IONIQ', 'ионик': 'IONIQ',\n    'kona': 'Kona', 'кона': 'Kona',\n}",
        "detail": "brand_synonyms",
        "documentation": {}
    },
    {
        "label": "FORD_MODEL_SYNONYMS",
        "kind": 5,
        "importPath": "brand_synonyms",
        "description": "brand_synonyms",
        "peekOfCode": "FORD_MODEL_SYNONYMS = {\n    'focus': 'Focus', 'фокус': 'Focus',\n    'mondeo': 'Mondeo', 'мондео': 'Mondeo',\n    'fiesta': 'Fiesta', 'фиеста': 'Fiesta',\n    'explorer': 'Explorer', 'эксплорер': 'Explorer',\n    'escape': 'Escape', 'эскейп': 'Escape',\n    'edge': 'Edge', 'эдж': 'Edge',\n    'mustang': 'Mustang', 'мустанг': 'Mustang',\n    'f-150': 'F-150', 'f150': 'F-150', 'ф-150': 'F-150', 'ф150': 'F-150',\n}",
        "detail": "brand_synonyms",
        "documentation": {}
    },
    {
        "label": "CHEVROLET_MODEL_SYNONYMS",
        "kind": 5,
        "importPath": "brand_synonyms",
        "description": "brand_synonyms",
        "peekOfCode": "CHEVROLET_MODEL_SYNONYMS = {\n    'cruze': 'Cruze', 'круз': 'Cruze',\n    'aveo': 'Aveo', 'авео': 'Aveo',\n    'lacetti': 'Lacetti', 'лачетти': 'Lacetti',\n    'captiva': 'Captiva', 'каптива': 'Captiva',\n    'orlando': 'Orlando', 'орландо': 'Orlando',\n    'camaro': 'Camaro', 'камаро': 'Camaro',\n    'corvette': 'Corvette', 'корвет': 'Corvette',\n    'tahoe': 'Tahoe', 'тахо': 'Tahoe',\n    'suburban': 'Suburban', 'сабурбан': 'Suburban',",
        "detail": "brand_synonyms",
        "documentation": {}
    },
    {
        "label": "LADA_MODEL_SYNONYMS",
        "kind": 5,
        "importPath": "brand_synonyms",
        "description": "brand_synonyms",
        "peekOfCode": "LADA_MODEL_SYNONYMS = {\n    'granta': 'Granta', 'гранта': 'Granta',\n    'vesta': 'Vesta', 'веста': 'Vesta',\n    'largus': 'Largus', 'ларгус': 'Largus',\n    'xray': 'XRAY', 'иксрей': 'XRAY', 'x-ray': 'XRAY',\n    'niva': 'Niva', 'нива': 'Niva',\n    'kalina': 'Kalina', 'калина': 'Kalina',\n    'priora': 'Priora', 'приора': 'Priora',\n    'samara': 'Samara', 'самара': 'Samara',\n}",
        "detail": "brand_synonyms",
        "documentation": {}
    },
    {
        "label": "MODEL_SYNONYMS",
        "kind": 5,
        "importPath": "brand_synonyms",
        "description": "brand_synonyms",
        "peekOfCode": "MODEL_SYNONYMS = {\n    **CHINESE_MODEL_SYNONYMS,\n    **BMW_MODEL_SYNONYMS,\n    **MERCEDES_MODEL_SYNONYMS,\n    **AUDI_MODEL_SYNONYMS,\n    **VW_MODEL_SYNONYMS,\n    **TOYOTA_MODEL_SYNONYMS,\n    **HONDA_MODEL_SYNONYMS,\n    **MAZDA_MODEL_SYNONYMS,\n    **LEXUS_MODEL_SYNONYMS,",
        "detail": "brand_synonyms",
        "documentation": {}
    },
    {
        "label": "OTECHESTVENNYE",
        "kind": 5,
        "importPath": "brand_synonyms",
        "description": "brand_synonyms",
        "peekOfCode": "OTECHESTVENNYE = {'Москвич', 'Lada', 'УАЗ', 'ГАЗ', 'КАМАЗ'}\n# Функция для получения всех уникальных брендов из базы данных\n@lru_cache(maxsize=1)\ndef get_all_brands_from_db():\n    \"\"\"Получает все уникальные бренды из базы данных\"\"\"\n    db_path = os.path.join(os.path.dirname(__file__), 'instance', 'cars.db')\n    if not os.path.exists(db_path):\n        return set()\n    try:\n        with sqlite3.connect(db_path) as conn:",
        "detail": "brand_synonyms",
        "documentation": {}
    },
    {
        "label": "EXTENDED_BRAND_SYNONYMS",
        "kind": 5,
        "importPath": "brand_synonyms",
        "description": "brand_synonyms",
        "peekOfCode": "EXTENDED_BRAND_SYNONYMS = create_extended_brand_synonyms()",
        "detail": "brand_synonyms",
        "documentation": {}
    },
    {
        "label": "API_URL",
        "kind": 5,
        "importPath": "car_159_info",
        "description": "car_159_info",
        "peekOfCode": "API_URL = 'http://127.0.0.1:5000/api/cars/159/details?used=true'\nresponse = requests.get(API_URL)\nif response.status_code == 200:\n    data = response.json()\n    if data.get('success'):\n        result = data['data']\n        print('=== Основная информация ===')\n        for k, v in result['characteristics'].items():\n            print(f'{k}: {v}')\n        print('\\n=== Опции ===')",
        "detail": "car_159_info",
        "documentation": {}
    },
    {
        "label": "response",
        "kind": 5,
        "importPath": "car_159_info",
        "description": "car_159_info",
        "peekOfCode": "response = requests.get(API_URL)\nif response.status_code == 200:\n    data = response.json()\n    if data.get('success'):\n        result = data['data']\n        print('=== Основная информация ===')\n        for k, v in result['characteristics'].items():\n            print(f'{k}: {v}')\n        print('\\n=== Опции ===')\n        for group in result['options']['groups']:",
        "detail": "car_159_info",
        "documentation": {}
    },
    {
        "label": "CarParser",
        "kind": 6,
        "importPath": "car_parser",
        "description": "car_parser",
        "peekOfCode": "class CarParser:\n    \"\"\"Парсер для извлечения информации об автомобилях с сайта aaa-motors.ru\"\"\"\n    def __init__(self):\n        self.session = requests.Session()\n        self.session.headers.update({\n            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'\n        })\n        # Маппинг марок для URL\n        self.brand_mapping = {\n            'BMW': 'bmw',",
        "detail": "car_parser",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "car_parser",
        "description": "car_parser",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass CarParser:\n    \"\"\"Парсер для извлечения информации об автомобилях с сайта aaa-motors.ru\"\"\"\n    def __init__(self):\n        self.session = requests.Session()\n        self.session.headers.update({\n            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'\n        })\n        # Маппинг марок для URL\n        self.brand_mapping = {",
        "detail": "car_parser",
        "documentation": {}
    },
    {
        "label": "car_parser",
        "kind": 5,
        "importPath": "car_parser",
        "description": "car_parser",
        "peekOfCode": "car_parser = CarParser()",
        "detail": "car_parser",
        "documentation": {}
    },
    {
        "label": "check_body_types",
        "kind": 2,
        "importPath": "check_body_types",
        "description": "check_body_types",
        "peekOfCode": "def check_body_types():\n    conn = sqlite3.connect(DB_PATH)\n    cursor = conn.cursor()\n    body_type_counts = defaultdict(int)\n    drive_type_counts = defaultdict(int)\n    print(\"Проверяем body_type и driving_gear_type в таблицах car и used_car...\")\n    for table in ['car', 'used_car']:\n        try:\n            cursor.execute(f\"SELECT body_type, driving_gear_type FROM {table}\")\n            rows = cursor.fetchall()",
        "detail": "check_body_types",
        "documentation": {}
    },
    {
        "label": "DB_PATH",
        "kind": 5,
        "importPath": "check_body_types",
        "description": "check_body_types",
        "peekOfCode": "DB_PATH = 'instance/cars.db'\ndef check_body_types():\n    conn = sqlite3.connect(DB_PATH)\n    cursor = conn.cursor()\n    body_type_counts = defaultdict(int)\n    drive_type_counts = defaultdict(int)\n    print(\"Проверяем body_type и driving_gear_type в таблицах car и used_car...\")\n    for table in ['car', 'used_car']:\n        try:\n            cursor.execute(f\"SELECT body_type, driving_gear_type FROM {table}\")",
        "detail": "check_body_types",
        "documentation": {}
    },
    {
        "label": "check_database",
        "kind": 2,
        "importPath": "check_db",
        "description": "check_db",
        "peekOfCode": "def check_database():\n    try:\n        conn = sqlite3.connect('instance/cars.db')\n        cursor = conn.cursor()\n        # Проверяем таблицы\n        cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table'\")\n        tables = cursor.fetchall()\n        print(\"Таблицы в базе:\", [t[0] for t in tables])\n        # Проверяем количество записей\n        if ('car',) in tables:",
        "detail": "check_db",
        "documentation": {}
    },
    {
        "label": "conn",
        "kind": 5,
        "importPath": "check_drive_types",
        "description": "check_drive_types",
        "peekOfCode": "conn = sqlite3.connect('instance/cars.db')\ncursor = conn.cursor()\n# Проверяем CAR table\ncursor.execute('SELECT COUNT(*) FROM car WHERE body_type = \"Внедорожник\" AND driving_gear_type = \"полный\"')\ncar_count = cursor.fetchone()[0]\nprint(f'CAR table - внедорожники с полным приводом: {car_count}')\n# Проверяем USED_CAR table\ncursor.execute('SELECT COUNT(*) FROM used_car WHERE body_type = \"Внедорожник\" AND driving_gear_type = \"Полный\"')\nused_car_count = cursor.fetchone()[0]\nprint(f'USED_CAR table - внедорожники с полным приводом: {used_car_count}')",
        "detail": "check_drive_types",
        "documentation": {}
    },
    {
        "label": "cursor",
        "kind": 5,
        "importPath": "check_drive_types",
        "description": "check_drive_types",
        "peekOfCode": "cursor = conn.cursor()\n# Проверяем CAR table\ncursor.execute('SELECT COUNT(*) FROM car WHERE body_type = \"Внедорожник\" AND driving_gear_type = \"полный\"')\ncar_count = cursor.fetchone()[0]\nprint(f'CAR table - внедорожники с полным приводом: {car_count}')\n# Проверяем USED_CAR table\ncursor.execute('SELECT COUNT(*) FROM used_car WHERE body_type = \"Внедорожник\" AND driving_gear_type = \"Полный\"')\nused_car_count = cursor.fetchone()[0]\nprint(f'USED_CAR table - внедорожники с полным приводом: {used_car_count}')\n# Проверяем общее количество внедорожников",
        "detail": "check_drive_types",
        "documentation": {}
    },
    {
        "label": "car_count",
        "kind": 5,
        "importPath": "check_drive_types",
        "description": "check_drive_types",
        "peekOfCode": "car_count = cursor.fetchone()[0]\nprint(f'CAR table - внедорожники с полным приводом: {car_count}')\n# Проверяем USED_CAR table\ncursor.execute('SELECT COUNT(*) FROM used_car WHERE body_type = \"Внедорожник\" AND driving_gear_type = \"Полный\"')\nused_car_count = cursor.fetchone()[0]\nprint(f'USED_CAR table - внедорожники с полным приводом: {used_car_count}')\n# Проверяем общее количество внедорожников\ncursor.execute('SELECT COUNT(*) FROM car WHERE body_type = \"Внедорожник\"')\ncar_suvs = cursor.fetchone()[0]\ncursor.execute('SELECT COUNT(*) FROM used_car WHERE body_type = \"Внедорожник\"')",
        "detail": "check_drive_types",
        "documentation": {}
    },
    {
        "label": "used_car_count",
        "kind": 5,
        "importPath": "check_drive_types",
        "description": "check_drive_types",
        "peekOfCode": "used_car_count = cursor.fetchone()[0]\nprint(f'USED_CAR table - внедорожники с полным приводом: {used_car_count}')\n# Проверяем общее количество внедорожников\ncursor.execute('SELECT COUNT(*) FROM car WHERE body_type = \"Внедорожник\"')\ncar_suvs = cursor.fetchone()[0]\ncursor.execute('SELECT COUNT(*) FROM used_car WHERE body_type = \"Внедорожник\"')\nused_car_suvs = cursor.fetchone()[0]\nprint(f'Всего внедорожников: CAR={car_suvs}, USED_CAR={used_car_suvs}')\n# Проверяем все варианты типов привода\ncursor.execute('SELECT DISTINCT driving_gear_type FROM car WHERE body_type = \"Внедорожник\"')",
        "detail": "check_drive_types",
        "documentation": {}
    },
    {
        "label": "car_suvs",
        "kind": 5,
        "importPath": "check_drive_types",
        "description": "check_drive_types",
        "peekOfCode": "car_suvs = cursor.fetchone()[0]\ncursor.execute('SELECT COUNT(*) FROM used_car WHERE body_type = \"Внедорожник\"')\nused_car_suvs = cursor.fetchone()[0]\nprint(f'Всего внедорожников: CAR={car_suvs}, USED_CAR={used_car_suvs}')\n# Проверяем все варианты типов привода\ncursor.execute('SELECT DISTINCT driving_gear_type FROM car WHERE body_type = \"Внедорожник\"')\ncar_drive_types = cursor.fetchall()\ncursor.execute('SELECT DISTINCT driving_gear_type FROM used_car WHERE body_type = \"Внедорожник\"')\nused_car_drive_types = cursor.fetchall()\nprint(f'Типы привода у внедорожников: CAR={[row[0] for row in car_drive_types]}, USED_CAR={[row[0] for row in used_car_drive_types]}')",
        "detail": "check_drive_types",
        "documentation": {}
    },
    {
        "label": "used_car_suvs",
        "kind": 5,
        "importPath": "check_drive_types",
        "description": "check_drive_types",
        "peekOfCode": "used_car_suvs = cursor.fetchone()[0]\nprint(f'Всего внедорожников: CAR={car_suvs}, USED_CAR={used_car_suvs}')\n# Проверяем все варианты типов привода\ncursor.execute('SELECT DISTINCT driving_gear_type FROM car WHERE body_type = \"Внедорожник\"')\ncar_drive_types = cursor.fetchall()\ncursor.execute('SELECT DISTINCT driving_gear_type FROM used_car WHERE body_type = \"Внедорожник\"')\nused_car_drive_types = cursor.fetchall()\nprint(f'Типы привода у внедорожников: CAR={[row[0] for row in car_drive_types]}, USED_CAR={[row[0] for row in used_car_drive_types]}')\nconn.close()",
        "detail": "check_drive_types",
        "documentation": {}
    },
    {
        "label": "car_drive_types",
        "kind": 5,
        "importPath": "check_drive_types",
        "description": "check_drive_types",
        "peekOfCode": "car_drive_types = cursor.fetchall()\ncursor.execute('SELECT DISTINCT driving_gear_type FROM used_car WHERE body_type = \"Внедорожник\"')\nused_car_drive_types = cursor.fetchall()\nprint(f'Типы привода у внедорожников: CAR={[row[0] for row in car_drive_types]}, USED_CAR={[row[0] for row in used_car_drive_types]}')\nconn.close()",
        "detail": "check_drive_types",
        "documentation": {}
    },
    {
        "label": "used_car_drive_types",
        "kind": 5,
        "importPath": "check_drive_types",
        "description": "check_drive_types",
        "peekOfCode": "used_car_drive_types = cursor.fetchall()\nprint(f'Типы привода у внедорожников: CAR={[row[0] for row in car_drive_types]}, USED_CAR={[row[0] for row in used_car_drive_types]}')\nconn.close()",
        "detail": "check_drive_types",
        "documentation": {}
    },
    {
        "label": "check_dependencies",
        "kind": 2,
        "importPath": "check_system",
        "description": "check_system",
        "peekOfCode": "def check_dependencies():\n    \"\"\"Проверка зависимостей\"\"\"\n    print(\"🔍 Проверка зависимостей...\")\n    required_modules = [\n        'fastapi',\n        'uvicorn',\n        'sqlite3',\n        'requests',\n        'psutil'\n    ]",
        "detail": "check_system",
        "documentation": {}
    },
    {
        "label": "check_database",
        "kind": 2,
        "importPath": "check_system",
        "description": "check_system",
        "peekOfCode": "def check_database():\n    \"\"\"Проверка базы данных\"\"\"\n    print(\"\\n🗄️  Проверка базы данных...\")\n    db_path = \"instance/cars.db\"\n    if not os.path.exists(db_path):\n        print(f\"❌ База данных не найдена: {db_path}\")\n        return False\n    try:\n        with sqlite3.connect(db_path) as conn:\n            cursor = conn.cursor()",
        "detail": "check_system",
        "documentation": {}
    },
    {
        "label": "check_files",
        "kind": 2,
        "importPath": "check_system",
        "description": "check_system",
        "peekOfCode": "def check_files():\n    \"\"\"Проверка основных файлов\"\"\"\n    print(\"\\n📁 Проверка файлов...\")\n    required_files = [\n        'app.py',\n        'database.py',\n        'dialog_manager.py',\n        'nlp_processor.py',\n        'static/index.html',\n        'requirements.txt'",
        "detail": "check_system",
        "documentation": {}
    },
    {
        "label": "check_directories",
        "kind": 2,
        "importPath": "check_system",
        "description": "check_system",
        "peekOfCode": "def check_directories():\n    \"\"\"Проверка директорий\"\"\"\n    print(\"\\n📂 Проверка директорий...\")\n    directories = ['logs', 'reports', 'instance']\n    for directory in directories:\n        if not os.path.exists(directory):\n            os.makedirs(directory)\n            print(f\"📁 Создана директория: {directory}\")\n        else:\n            print(f\"✅ Директория существует: {directory}\")",
        "detail": "check_system",
        "documentation": {}
    },
    {
        "label": "test_imports",
        "kind": 2,
        "importPath": "check_system",
        "description": "check_system",
        "peekOfCode": "def test_imports():\n    \"\"\"Тест импорта модулей\"\"\"\n    print(\"\\n🧪 Тест импорта модулей...\")\n    modules = [\n        'app',\n        'database',\n        'dialog_manager',\n        'nlp_processor',\n        'user_history',\n        'fuzzy_search',",
        "detail": "check_system",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "check_system",
        "description": "check_system",
        "peekOfCode": "def main():\n    \"\"\"Основная функция\"\"\"\n    print(\"🚗 ПРОВЕРКА СИСТЕМЫ АВТОАССИСТЕНТА\")\n    print(\"=\" * 50)\n    checks = [\n        check_dependencies,\n        check_files,\n        check_directories,\n        check_database,\n        test_imports",
        "detail": "check_system",
        "documentation": {}
    },
    {
        "label": "test_query",
        "kind": 2,
        "importPath": "comprehensive_test",
        "description": "comprehensive_test",
        "peekOfCode": "def test_query(query, expected_type=None):\n    \"\"\"Тестирует один запрос\"\"\"\n    url = \"http://localhost:5000/api/chat\"\n    data = {\n        \"message\": query,\n        \"user_id\": \"test_user\"\n    }\n    try:\n        print(f\"\\n🔍 Тестируем: '{query}'\")\n        response = requests.post(url, json=data)",
        "detail": "comprehensive_test",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "comprehensive_test",
        "description": "comprehensive_test",
        "peekOfCode": "def main():\n    \"\"\"Основная функция тестирования\"\"\"\n    print(\"🚀 Начинаем комплексное тестирование системы\")\n    print(\"=\" * 60)\n    # Тестовые запросы по категориям\n    test_cases = [\n        # 1. Простые запросы о цветах\n        (\"найди красную машину\", \"llama_response\"),\n        (\"покажи синие автомобили\", \"llama_response\"),\n        (\"белый мерседес\", \"llama_response\"),",
        "detail": "comprehensive_test",
        "documentation": {}
    },
    {
        "label": "LLAMA_API_URL",
        "kind": 5,
        "importPath": "config",
        "description": "config",
        "peekOfCode": "LLAMA_API_URL = \"http://host.docker.internal:11434/api/generate\"\nLLAMA_API_KEY = \"your_api_key_here\"  # Замените на ваш ключ, если требуется",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "LLAMA_API_KEY",
        "kind": 5,
        "importPath": "config",
        "description": "config",
        "peekOfCode": "LLAMA_API_KEY = \"your_api_key_here\"  # Замените на ваш ключ, если требуется",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "CacheManager",
        "kind": 6,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "class CacheManager:\n    def __init__(self):\n        self.redis = redis.Redis(host='localhost', port=6380, decode_responses=True)\n    def get_simple_cache(self, query: str) -> Optional[str]:\n        key = f\"simple:{hashlib.md5(query.encode()).hexdigest()}\"\n        value = self.redis.get(key)\n        if isinstance(value, bytes):\n            return value.decode()\n        if isinstance(value, str):\n            return value",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "get_db",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def get_db():\n    conn = sqlite3.connect(DATABASE_PATH)\n    conn.row_factory = sqlite3.Row\n    # Гарантируем, что таблица api_logs существует\n    try:\n        cursor = conn.cursor()\n        cursor.execute('''\n            CREATE TABLE IF NOT EXISTS api_logs (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "get_tables",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def get_tables():\n    with get_db() as conn:\n        cursor = conn.cursor()\n        tables = cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table';\").fetchall()\n        return [t[0] for t in tables]\ndef get_table_columns(table_name):\n    with get_db() as conn:\n        cursor = conn.cursor()\n        columns = cursor.execute(f\"PRAGMA table_info({table_name});\").fetchall()\n        return [{'name': col[1], 'type': col[2]} for col in columns]",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "get_table_columns",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def get_table_columns(table_name):\n    with get_db() as conn:\n        cursor = conn.cursor()\n        columns = cursor.execute(f\"PRAGMA table_info({table_name});\").fetchall()\n        return [{'name': col[1], 'type': col[2]} for col in columns]\n# --- Безопасный log_query ---\ndef log_query(user, query_text, response):\n    with get_db() as conn:\n        cursor = conn.cursor()\n        user = escape(user)",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "log_query",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def log_query(user, query_text, response):\n    with get_db() as conn:\n        cursor = conn.cursor()\n        user = escape(user)\n        query_text = escape(query_text)\n        response = escape(response)\n        try:\n            cursor.execute('''CREATE TABLE IF NOT EXISTS chat_log (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                user TEXT,",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "get_chat_history",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def get_chat_history(limit=20):\n    with get_db() as conn:\n        cursor = conn.cursor()\n        cursor.execute('''CREATE TABLE IF NOT EXISTS chat_log (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            user TEXT,\n            query_text TEXT,\n            response TEXT,\n            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n        )''')",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "analyze_database",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def analyze_database():\n    with get_db() as conn:\n        cursor = conn.cursor()\n        tables = cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table';\").fetchall()\n        analysis = {}\n        for table in tables:\n            table_name = table[0]\n            columns = cursor.execute(f\"PRAGMA table_info({table_name});\").fetchall()\n            row_count = cursor.execute(f\"SELECT COUNT(*) FROM {table_name}\").fetchone()[0]\n            analysis[table_name] = {",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "safe_db_write",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def safe_db_write(query, params=None):\n    try:\n        with get_db() as conn:\n            conn.execute('BEGIN')\n            cursor = conn.cursor()\n            if params:\n                cursor.execute(query, params)\n            else:\n                cursor.execute(query)\n            conn.commit()",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "validate_car_data",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def validate_car_data(car):\n    year = car.get('manufacture_year')\n    price = car.get('price')\n    if not isinstance(year, int) or not (1950 <= year <= 2100):\n        return False\n    if not isinstance(price, (int, float)) or not (100_000 <= price <= 100_000_000):\n        return False\n    for field in ['mark', 'model', 'fuel_type', 'body_type', 'city']:\n        if not isinstance(car.get(field), str) or len(car[field]) > 100:\n            return False",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "get_first_deep",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def get_first_deep(val):\n    if isinstance(val, (list, tuple)):\n        return get_first_deep(val[0]) if val else None\n    return val\ndef normalize_brand(brand):\n    brand = get_first_deep(brand)\n    if not brand:\n        return None\n    b = str(brand).strip().lower()\n    return BRAND_SYNONYMS.get(b, str(brand).title())",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "normalize_brand",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def normalize_brand(brand):\n    brand = get_first_deep(brand)\n    if not brand:\n        return None\n    b = str(brand).strip().lower()\n    return BRAND_SYNONYMS.get(b, str(brand).title())\ndef is_otechestvenny(brand):\n    return normalize_brand(brand) in OTECHESTVENNYE\ndef is_modern(year):\n    return year >= 2010",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "is_otechestvenny",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def is_otechestvenny(brand):\n    return normalize_brand(brand) in OTECHESTVENNYE\ndef is_modern(year):\n    return year >= 2010\n# --- Обёртка для загрузки с валидацией и нормализацией ---\ndef insert_car(cursor, table, car):\n    # car: dict\n    if not validate_car_data(car):\n        return False\n    car['mark'] = normalize_brand(car.get('mark'))",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "is_modern",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def is_modern(year):\n    return year >= 2010\n# --- Обёртка для загрузки с валидацией и нормализацией ---\ndef insert_car(cursor, table, car):\n    # car: dict\n    if not validate_car_data(car):\n        return False\n    car['mark'] = normalize_brand(car.get('mark'))\n    cursor.execute(f'''INSERT INTO {table} (mark, model, manufacture_year, price, fuel_type, power, gear_box_type, body_type, city, availability) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)''',\n        (",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "insert_car",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def insert_car(cursor, table, car):\n    # car: dict\n    if not validate_car_data(car):\n        return False\n    car['mark'] = normalize_brand(car.get('mark'))\n    cursor.execute(f'''INSERT INTO {table} (mark, model, manufacture_year, price, fuel_type, power, gear_box_type, body_type, city, availability) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)''',\n        (\n            car.get('mark'), car.get('model'), car.get('manufacture_year'), car.get('price'),\n            car.get('fuel_type'), car.get('power'), car.get('gear_box_type'), car.get('body_type'),\n            car.get('city'), car.get('availability', 1)",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "fill_test_data",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def fill_test_data():\n    with get_db() as conn:\n        cursor = conn.cursor()\n        # Не добавляем тестовые данные\n        pass \n# Добавляем недостающую функцию close_db для совместимости с app.py\ndef close_db(exception=None):\n    \"\"\"Закрывает соединение с БД (для совместимости с Flask)\"\"\"\n    pass\n# Добавляем кэшированную функцию получения всех брендов",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "close_db",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def close_db(exception=None):\n    \"\"\"Закрывает соединение с БД (для совместимости с Flask)\"\"\"\n    pass\n# Добавляем кэшированную функцию получения всех брендов\n@lru_cache(maxsize=1)\ndef get_all_brands_cached():\n    \"\"\"Получает все уникальные бренды из БД с кэшированием\"\"\"\n    try:\n        with get_db() as conn:\n            cursor = conn.cursor()",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "get_all_brands_cached",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def get_all_brands_cached():\n    \"\"\"Получает все уникальные бренды из БД с кэшированием\"\"\"\n    try:\n        with get_db() as conn:\n            cursor = conn.cursor()\n            cursor.execute(\"SELECT DISTINCT mark FROM car ORDER BY mark\")\n            brands_car = [row[0] for row in cursor.fetchall()]\n            cursor.execute(\"SELECT DISTINCT mark FROM used_car ORDER BY mark\")\n            brands_used = [row[0] for row in cursor.fetchall()]\n            return sorted(set(brands_car + brands_used))",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "get_all_models_cached",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def get_all_models_cached():\n    \"\"\"Получает все уникальные модели из БД с кэшированием\"\"\"\n    try:\n        with get_db() as conn:\n            cursor = conn.cursor()\n            cursor.execute(\"SELECT DISTINCT model FROM car ORDER BY model\")\n            models_car = [row[0] for row in cursor.fetchall()]\n            cursor.execute(\"SELECT DISTINCT model FROM used_car ORDER BY model\")\n            models_used = [row[0] for row in cursor.fetchall()]\n            return sorted(set(models_car + models_used))",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "get_car_options",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def get_car_options(brand: Optional[str] = None, model: Optional[str] = None, used: bool = False) -> list:\n    \"\"\"\n    Возвращает список опций (характеристик) для заданной марки и модели.\n    Если не указаны brand/model, возвращает все доступные варианты.\n    \"\"\"\n    table = 'used_car' if used else 'car'\n    query = f\"SELECT * FROM {table} WHERE 1=1\"\n    params = []\n    if brand:\n        query += \" AND mark = ?\"",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "get_full_car_info",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def get_full_car_info(\n    brand: Optional[str] = None,\n    model: Optional[str] = None,\n    car_id: Optional[int] = None,\n    used: bool = False\n) -> Optional[dict]:\n    table = 'used_car' if used else 'car'\n    pic_table = 'used_car_picture' if used else 'picture'\n    with get_db() as conn:\n        cursor = conn.cursor()",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "get_all_brands",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def get_all_brands(used: bool = False) -> list:\n    table = 'used_car' if used else 'car'\n    with get_db() as conn:\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT DISTINCT mark FROM {table} ORDER BY mark\")\n        return [row[0] for row in cursor.fetchall()]\ndef get_all_models(used: bool = False) -> list:\n    table = 'used_car' if used else 'car'\n    with get_db() as conn:\n        cursor = conn.cursor()",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "get_all_models",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def get_all_models(used: bool = False) -> list:\n    table = 'used_car' if used else 'car'\n    with get_db() as conn:\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT DISTINCT model FROM {table} ORDER BY model\")\n        return [row[0] for row in cursor.fetchall()]\ndef get_all_cities(used: bool = False) -> list:\n    \"\"\"Получает все уникальные города из базы данных\"\"\"\n    table = 'used_car' if used else 'car'\n    with get_db() as conn:",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "get_all_cities",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def get_all_cities(used: bool = False) -> list:\n    \"\"\"Получает все уникальные города из базы данных\"\"\"\n    table = 'used_car' if used else 'car'\n    with get_db() as conn:\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT DISTINCT city FROM {table} WHERE city IS NOT NULL AND city != '' ORDER BY city\")\n        return [row[0] for row in cursor.fetchall()]\n@lru_cache(maxsize=1)\ndef get_all_cities_cached():\n    \"\"\"Получает все уникальные города из БД с кэшированием\"\"\"",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "get_all_cities_cached",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def get_all_cities_cached():\n    \"\"\"Получает все уникальные города из БД с кэшированием\"\"\"\n    try:\n        cities_car = get_all_cities(used=False)\n        cities_used = get_all_cities(used=True)\n        return sorted(set(cities_car + cities_used))\n    except Exception as e:\n        print(f\"Ошибка получения городов: {e}\")\n        return []\ndef get_model_keywords(model):",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "get_model_keywords",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def get_model_keywords(model):\n    \"\"\"Возвращает список ключевых подстрок для поиска по модели (универсально для BMW, Audi, Mercedes и др.)\"\"\"\n    if not model:\n        return []\n    m = str(model).lower().replace(' ', '')\n    keywords = set()\n    keywords.add(m)\n    # Точные соответствия для BMW X-серии\n    if m == 'x5':\n        keywords.update(['x5', 'х5', 'x 5', 'x-5'])",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "get_brand_keywords",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def get_brand_keywords(brand):\n    \"\"\"Возвращает список ключевых подстрок для поиска по бренду (например, BMW, B M W, БМВ)\"\"\"\n    if not brand:\n        return []\n    b = str(brand).lower().replace(' ', '')\n    keywords = set()\n    keywords.add(b)\n    if b == 'bmw':\n        keywords.update(['bmw', 'бмв', 'b m w'])\n    if b == 'audi':",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "filter_cars",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def filter_cars(brand=None, model=None, year=None, price_min=None, price_max=None, city=None, body_type=None, used=False) -> list:\n    table = 'used_car' if used else 'car'\n    query = f\"SELECT * FROM {table} WHERE 1=1\"\n    params = []\n    # --- Фильтрация по бренду: LIKE + поддержка синонимов ---\n    if brand:\n        brand_keywords = get_brand_keywords(brand)\n        if brand_keywords:\n            brand_filters = []\n            for kw in brand_keywords:",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "compare_cars",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def compare_cars(car_list: list) -> list:\n    \"\"\"\n    car_list: список словарей {'brand': ..., 'model': ..., 'used': ...}\n    Возвращает список dict с полной инфой для сравнения (через smart_filter_cars)\n    \"\"\"\n    results = []\n    for car in car_list:\n        brand = car.get('brand')\n        model = car.get('model')\n        used = car.get('used', None)",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "get_dealer_centers_for_car",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def get_dealer_centers_for_car(brand: str, model: str, city: Optional[str] = None) -> list:\n    \"\"\"\n    Получает список дилерских центров для конкретного автомобиля\n    \"\"\"\n    with get_db() as conn:\n        cursor = conn.cursor()\n        # Сначала ищем в таблице car/used_car\n        query = \"\"\"\n            SELECT DISTINCT dealer_center, city \n            FROM car ",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "get_dealer_center_info",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def get_dealer_center_info(dealer_name: str) -> Optional[Dict[str, Any]]:\n    \"\"\"\n    Получает подробную информацию о дилерском центре\n    \"\"\"\n    with get_db() as conn:\n        cursor = conn.cursor()\n        # Ищем в таблице dealer_centers\n        cursor.execute(\"\"\"\n            SELECT name, address, phone, website, city, brands, working_hours\n            FROM dealer_centers ",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "add_dealer_center",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def add_dealer_center(name: str, address: Optional[str] = None, phone: Optional[str] = None, \n                     website: Optional[str] = None, city: Optional[str] = None, \n                     brands: Optional[List[str]] = None, working_hours: Optional[str] = None) -> bool:\n    \"\"\"\n    Добавляет новый дилерский центр\n    \"\"\"\n    try:\n        with get_db() as conn:\n            cursor = conn.cursor()\n            brands_json = json.dumps(brands) if brands is not None else None",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "get_all_dealer_centers",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def get_all_dealer_centers(city: Optional[str] = None) -> List[Dict[str, Any]]:\n    \"\"\"\n    Получает список всех дилерских центров\n    \"\"\"\n    with get_db() as conn:\n        cursor = conn.cursor()\n        query = \"SELECT name, address, phone, website, city, brands, working_hours FROM dealer_centers\"\n        params = []\n        if city:\n            query += \" WHERE city = ?\"",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "add_column_if_not_exists",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def add_column_if_not_exists(cursor, table, column, coltype):\n    cursor.execute(f\"PRAGMA table_info({table})\")\n    if column not in [row[1] for row in cursor.fetchall()]:\n        cursor.execute(f\"ALTER TABLE {table} ADD COLUMN {column} {coltype}\")\ndef add_lat_lon_to_dealer_centers():\n    \"\"\"Добавляет поля latitude и longitude в таблицу dealer_centers, если их нет\"\"\"\n    with get_db() as conn:\n        cursor = conn.cursor()\n        add_column_if_not_exists(cursor, 'dealer_centers', 'latitude', 'REAL')\n        add_column_if_not_exists(cursor, 'dealer_centers', 'longitude', 'REAL')",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "add_lat_lon_to_dealer_centers",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def add_lat_lon_to_dealer_centers():\n    \"\"\"Добавляет поля latitude и longitude в таблицу dealer_centers, если их нет\"\"\"\n    with get_db() as conn:\n        cursor = conn.cursor()\n        add_column_if_not_exists(cursor, 'dealer_centers', 'latitude', 'REAL')\n        add_column_if_not_exists(cursor, 'dealer_centers', 'longitude', 'REAL')\n        conn.commit()\nYANDEX_API_KEY = 'd839c21f-c590-43dc-a18b-f2e5c62baf8b'\ndef geocode_address(address: str) -> tuple[float, float] | None:\n    \"\"\"Получает координаты по адресу через Яндекс.Карты\"\"\"",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "geocode_address",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def geocode_address(address: str) -> tuple[float, float] | None:\n    \"\"\"Получает координаты по адресу через Яндекс.Карты\"\"\"\n    url = f'https://geocode-maps.yandex.ru/1.x/?apikey={YANDEX_API_KEY}&geocode={address}&format=json'\n    resp = requests.get(url)\n    if resp.status_code == 200:\n        try:\n            pos = resp.json()['response']['GeoObjectCollection']['featureMember'][0]['GeoObject']['Point']['pos']\n            lon, lat = map(float, pos.split())\n            return lat, lon\n        except Exception:",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "update_all_dealer_coords",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def update_all_dealer_coords():\n    \"\"\"Обновляет координаты всех ДЦ по адресу\"\"\"\n    with get_db() as conn:\n        cursor = conn.cursor()\n        cursor.execute('SELECT id, address FROM dealer_centers')\n        for row in cursor.fetchall():\n            dc_id, address = row\n            coords = geocode_address(address)\n            if coords:\n                lat, lon = coords",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "get_dealer_centers_with_coords",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def get_dealer_centers_with_coords() -> list:\n    \"\"\"Возвращает все ДЦ с координатами\"\"\"\n    with get_db() as conn:\n        cursor = conn.cursor()\n        cursor.execute('SELECT name, address, latitude, longitude, phone, website FROM dealer_centers')\n        return [dict(zip(['name','address','latitude','longitude','phone','website'], row)) for row in cursor.fetchall()] \ndef ensure_dealer_centers_filled():\n    \"\"\"Заполняет таблицу dealer_centers адресами и контактами из предоставленного списка, если их нет.\"\"\"\n    dealers = [\n        # Воронеж",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "ensure_dealer_centers_filled",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def ensure_dealer_centers_filled():\n    \"\"\"Заполняет таблицу dealer_centers адресами и контактами из предоставленного списка, если их нет.\"\"\"\n    dealers = [\n        # Воронеж\n        {\"name\": \"ААА Моторс\", \"address\": \"Воронеж, ул. Остужева, 68\", \"city\": \"Воронеж\", \"brands\": \"\", \"phone\": \"\", \"website\": \"\", \"working_hours\": \"\"},\n        # Краснодар\n        {\"name\": \"ААА Моторс\", \"address\": \"Краснодар, ул. Аэропортовская, 4/1\", \"city\": \"Краснодар\", \"brands\": \"\", \"phone\": \"\", \"website\": \"\", \"working_hours\": \"\"},\n        {\"name\": \"ААА Моторс — дилер DongFeng\", \"address\": \"Краснодар, ул. Аэропортовская, 4а\", \"city\": \"Краснодар\", \"brands\": \"DongFeng\", \"phone\": \"\", \"website\": \"\", \"working_hours\": \"\"},\n        {\"name\": \"ААА Моторс\", \"address\": \"Краснодар, ул. Дзержинского, 231/2\", \"city\": \"Краснодар\", \"brands\": \"\", \"phone\": \"\", \"website\": \"\", \"working_hours\": \"\"},\n        # Ростов-на-Дону",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "create_dealer_centers_table_if_not_exists",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def create_dealer_centers_table_if_not_exists():\n    with get_db() as conn:\n        cursor = conn.cursor()\n        cursor.execute('''\n            CREATE TABLE IF NOT EXISTS dealer_centers (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                name TEXT,\n                address TEXT,\n                city TEXT,\n                brands TEXT,",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "map_dealer_center_codes",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def map_dealer_center_codes():\n    \"\"\"\n    Сопоставляет коды dealer_center из car/used_car с дилерскими центрами из dealer_centers.\n    Возвращает dict: код → {name, address, city, ...}\n    \"\"\"\n    with get_db() as conn:\n        cursor = conn.cursor()\n        # Получаем все дилерские центры\n        cursor.execute('SELECT id, name, address, city, brands FROM dealer_centers')\n        all_dealers = cursor.fetchall()",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "get_dealer_center_info_by_code",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def get_dealer_center_info_by_code(code: str):\n    \"\"\"\n    Возвращает полную информацию о дилерском центре по коду dealer_center (например, AUDI_KRD).\n    Если не найдено — возвращает None.\n    \"\"\"\n    mapping = map_dealer_center_codes()\n    return mapping.get(code) or None \n# --- Безопасный execute_query ---\ndef execute_query(query: str, params: Optional[List[Any]] = None) -> List[Tuple]:\n    try:",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "execute_query",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def execute_query(query: str, params: Optional[List[Any]] = None) -> List[Tuple]:\n    try:\n        with get_db() as conn:\n            cursor = conn.cursor()\n            # Ограничение SELECT\n            if query.strip().upper().startswith('SELECT') and 'LIMIT' not in query.upper():\n                query += ' LIMIT 1000'\n            if params:\n                cursor.execute(query, params)\n            else:",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "get_all_unique_values",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def get_all_unique_values():\n    \"\"\"Кэширует уникальные значения по ключевым полям для car и used_car\"\"\"\n    import sqlite3\n    DB_PATH = 'instance/cars.db'\n    fields = ['mark', 'model', 'fuel_type', 'body_type', 'gear_box_type', 'driving_gear_type']\n    uniques = {f: set() for f in fields}\n    conn = sqlite3.connect(DB_PATH)\n    cursor = conn.cursor()\n    for table in ['car', 'used_car']:\n        for f in fields:",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "get_all_unique_values_lower",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def get_all_unique_values_lower():\n    import sqlite3\n    DB_PATH = 'instance/cars.db'\n    fields = ['mark', 'model', 'fuel_type', 'body_type', 'gear_box_type', 'driving_gear_type']\n    uniques = {f: set() for f in fields}\n    conn = sqlite3.connect(DB_PATH)\n    cursor = conn.cursor()\n    for table in ['car', 'used_car']:\n        for f in fields:\n            try:",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "normalize_str",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def normalize_str(val):\n    if not val:\n        return ''\n    return unicodedata.normalize('NFKC', str(val)).strip().lower()\nBRAND_SYNONYMS = {\n    'bmw': ['bmw', 'бмв'],\n    'mercedes': ['mercedes', 'mercedes-benz', 'мерседес', 'мерседес-бенц'],\n    'audi': ['audi', 'ауди'],\n}\ndef is_brand_match(brand, target):",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "is_brand_match",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def is_brand_match(brand, target):\n    brand = normalize_str(brand)\n    target = normalize_str(target)\n    for canon, variants in BRAND_SYNONYMS.items():\n        if brand in variants and (target in variants or canon in target):\n            return True\n    return brand == target\n# --- Маппинг значений фильтров с английских на русские ---\nFILTER_VALUE_MAP = {\n    'fuel_type': {",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "map_filter_value",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def map_filter_value(field, value):\n    value = get_first_deep(value)\n    if not value:\n        return value\n    v = str(value).strip().lower()\n    return FILTER_VALUE_MAP.get(field, {}).get(v, value)\ndef search_all_cars(\n    brand: Optional[str] = None,\n    model: Optional[str] = None,\n    year_from: Optional[int] = None,",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "search_all_cars",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def search_all_cars(\n    brand: Optional[str] = None,\n    model: Optional[str] = None,\n    year_from: Optional[int] = None,\n    year_to: Optional[int] = None,\n    price_from: Optional[float] = None,\n    price_to: Optional[float] = None,\n    fuel_type: Optional[str] = None,\n    transmission: Optional[str] = None,\n    body_type: Optional[str] = None,",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "smart_filter_cars",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def smart_filter_cars(brand=None, model=None, year=None, price_min=None, price_max=None, city=None, body_type=None, used=None):\n    \"\"\"\n    Поиск автомобилей:\n    - Если задана модель: ищем по бренду и всем синонимам/похожим моделям (LIKE, синонимы, подстроки)\n    - Если не найдено — возвращаем все автомобили бренда с пометкой\n    - Если не задана модель — ищем только по бренду\n    Возвращает: (результат, пояснение)\n    \"\"\"\n    tables = ['car', 'used_car']\n    all_results = []",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "get_recent_cars_from_db",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def get_recent_cars_from_db(limit: Optional[int] = None):\n    \"\"\"\n    Возвращает limit последних автомобилей (car + used_car), отсортированных по году выпуска и цене (сначала новые, потом подержанные)\n    Теперь для каждого авто подгружаются опции (options).\n    Если limit=None, возвращает все автомобили.\n    \"\"\"\n    with get_db() as conn:\n        cursor = conn.cursor()\n        # Новые авто\n        cursor.execute(\"\"\"",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "create_indexes",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def create_indexes():\n    with get_db() as conn:\n        cursor = conn.cursor()\n        try:\n            cursor.execute('CREATE INDEX IF NOT EXISTS idx_car_mark ON car (mark)')\n            cursor.execute('CREATE INDEX IF NOT EXISTS idx_car_model ON car (model)')\n            cursor.execute('CREATE INDEX IF NOT EXISTS idx_car_year ON car (manufacture_year)')\n            cursor.execute('CREATE INDEX IF NOT EXISTS idx_car_city ON car (city)')\n            cursor.execute('CREATE INDEX IF NOT EXISTS idx_car_dealer ON car (dealer_center)')\n            conn.commit()",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "init_car_db",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def init_car_db():\n    with init_lock:\n        with get_db() as conn:\n            cursor = conn.cursor()\n            cursor.execute('''CREATE TABLE IF NOT EXISTS car (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                mark TEXT,\n                model TEXT,\n                manufacture_year INTEGER,\n                price INTEGER,",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "ensure_api_logs_table",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def ensure_api_logs_table():\n    with get_db() as conn:\n        cursor = conn.cursor()\n        cursor.execute('''\n            CREATE TABLE IF NOT EXISTS api_logs (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,\n                endpoint TEXT,\n                method TEXT,\n                status_code INTEGER,",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "get_car_options_by_car_id",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def get_car_options_by_car_id(car_id: int) -> List[Dict[str, Any]]:\n    \"\"\"Получает все опции для конкретного автомобиля\"\"\"\n    try:\n        with get_db() as conn:\n            cursor = conn.cursor()\n            cursor.execute(\"\"\"\n                SELECT id, car_id, code, description \n                FROM option \n                WHERE car_id = ? \n                ORDER BY code",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "get_all_options",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def get_all_options():\n    \"\"\"\n    Получает все уникальные опции (code, description) из таблицы option\n    \"\"\"\n    with get_db() as conn:\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT DISTINCT code, description FROM option ORDER BY code\")\n        return [\n            {\"code\": row[0], \"description\": row[1]} for row in cursor.fetchall()\n        ]",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "get_unique_option_codes",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def get_unique_option_codes() -> List[str]:\n    \"\"\"Получает все уникальные коды опций\"\"\"\n    try:\n        with get_db() as conn:\n            cursor = conn.cursor()\n            cursor.execute(\"\"\"\n                SELECT DISTINCT code \n                FROM option \n                WHERE code IS NOT NULL \n                ORDER BY code",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "search_options_by_code",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def search_options_by_code(code: str) -> List[Dict[str, Any]]:\n    \"\"\"Ищет опции по коду\"\"\"\n    try:\n        with get_db() as conn:\n            cursor = conn.cursor()\n            cursor.execute(\"\"\"\n                SELECT id, car_id, code, description \n                FROM option \n                WHERE code LIKE ? \n                ORDER BY car_id, code",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "get_options_statistics",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def get_options_statistics() -> Dict[str, Any]:\n    \"\"\"Получает статистику по опциям\"\"\"\n    try:\n        with get_db() as conn:\n            cursor = conn.cursor()\n            # Общее количество опций\n            total_options = cursor.execute(\"SELECT COUNT(*) FROM option\").fetchone()[0]\n            # Количество уникальных кодов\n            unique_codes = cursor.execute(\"SELECT COUNT(DISTINCT code) FROM option WHERE code IS NOT NULL\").fetchone()[0]\n            # Топ-10 самых популярных опций",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "get_car_with_options",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def get_car_with_options(car_id: int) -> Optional[Dict[str, Any]]:\n    \"\"\"Получает автомобиль с его опциями\"\"\"\n    try:\n        with get_db() as conn:\n            cursor = conn.cursor()\n            # Получаем информацию об автомобиле\n            cursor.execute(\"\"\"\n                SELECT * FROM car WHERE id = ?\n            \"\"\", (car_id,))\n            car_row = cursor.fetchone()",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "init_quick_scenarios_table",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def init_quick_scenarios_table():\n    \"\"\"Создаёт таблицу сценариев, если не существует\"\"\"\n    with get_db() as conn:\n        cursor = conn.cursor()\n        cursor.execute('''CREATE TABLE IF NOT EXISTS quick_scenarios (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            title TEXT NOT NULL,\n            icon TEXT,\n            query TEXT NOT NULL,\n            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "get_all_quick_scenarios",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def get_all_quick_scenarios():\n    with get_db() as conn:\n        cursor = conn.cursor()\n        cursor.execute('SELECT id, title, icon, query FROM quick_scenarios ORDER BY id ASC')\n        return [\n            {'id': row[0], 'title': row[1], 'icon': row[2], 'query': row[3]}\n            for row in cursor.fetchall()\n        ]\ndef add_quick_scenario(title, icon, query):\n    with get_db() as conn:",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "add_quick_scenario",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def add_quick_scenario(title, icon, query):\n    with get_db() as conn:\n        cursor = conn.cursor()\n        cursor.execute('''INSERT INTO quick_scenarios (title, icon, query) VALUES (?, ?, ?)''', (title, icon, query))\n        conn.commit()\n        return cursor.lastrowid\ndef update_quick_scenario(scenario_id, title, icon, query):\n    with get_db() as conn:\n        cursor = conn.cursor()\n        cursor.execute('''UPDATE quick_scenarios SET title=?, icon=?, query=?, updated_at=CURRENT_TIMESTAMP WHERE id=?''', (title, icon, query, scenario_id))",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "update_quick_scenario",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def update_quick_scenario(scenario_id, title, icon, query):\n    with get_db() as conn:\n        cursor = conn.cursor()\n        cursor.execute('''UPDATE quick_scenarios SET title=?, icon=?, query=?, updated_at=CURRENT_TIMESTAMP WHERE id=?''', (title, icon, query, scenario_id))\n        conn.commit()\n        return cursor.rowcount > 0\ndef delete_quick_scenario(scenario_id):\n    with get_db() as conn:\n        cursor = conn.cursor()\n        cursor.execute('DELETE FROM quick_scenarios WHERE id=?', (scenario_id,))",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "delete_quick_scenario",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def delete_quick_scenario(scenario_id):\n    with get_db() as conn:\n        cursor = conn.cursor()\n        cursor.execute('DELETE FROM quick_scenarios WHERE id=?', (scenario_id,))\n        conn.commit()\n        return cursor.rowcount > 0\ndef delete_cars_by_ids(ids):\n    \"\"\"Удаляет автомобили с заданными id из car и used_car. Возвращает количество удалённых.\"\"\"\n    if not ids:\n        return 0",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "delete_cars_by_ids",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def delete_cars_by_ids(ids):\n    \"\"\"Удаляет автомобили с заданными id из car и used_car. Возвращает количество удалённых.\"\"\"\n    if not ids:\n        return 0\n    with get_db() as conn:\n        cursor = conn.cursor()\n        q_marks = ','.join(['?']*len(ids))\n        deleted = 0\n        # Удаляем из car\n        cursor.execute(f\"DELETE FROM car WHERE id IN ({q_marks})\", ids)",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "delete_dealers_by_ids",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def delete_dealers_by_ids(ids):\n    \"\"\"Удаляет дилеров с заданными id из dealer_centers. Возвращает количество удалённых.\"\"\"\n    if not ids:\n        return 0\n    with get_db() as conn:\n        cursor = conn.cursor()\n        q_marks = ','.join(['?']*len(ids))\n        cursor.execute(f\"DELETE FROM dealer_centers WHERE id IN ({q_marks})\", ids)\n        deleted = cursor.rowcount\n        conn.commit()",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "get_cities_with_stats",
        "kind": 2,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "def get_cities_with_stats():\n    \"\"\"\n    Возвращает список городов с количеством машин (car + used_car), пустые значения как 'Не заполнено'.\n    [{\"name\": \"Москва\", \"count\": 40}, ...]\n    \"\"\"\n    with get_db() as conn:\n        cursor = conn.cursor()\n        # car\n        cursor.execute(\"SELECT city, COUNT(*) FROM car GROUP BY city\")\n        car_stats = cursor.fetchall()",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "DATABASE_PATH",
        "kind": 5,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "DATABASE_PATH = os.path.join(os.path.dirname(__file__), 'instance', 'cars.db')\n# Глобальный лок для инициализации\ninit_lock = threading.Lock()\n@contextmanager\ndef get_db():\n    conn = sqlite3.connect(DATABASE_PATH)\n    conn.row_factory = sqlite3.Row\n    # Гарантируем, что таблица api_logs существует\n    try:\n        cursor = conn.cursor()",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "init_lock",
        "kind": 5,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "init_lock = threading.Lock()\n@contextmanager\ndef get_db():\n    conn = sqlite3.connect(DATABASE_PATH)\n    conn.row_factory = sqlite3.Row\n    # Гарантируем, что таблица api_logs существует\n    try:\n        cursor = conn.cursor()\n        cursor.execute('''\n            CREATE TABLE IF NOT EXISTS api_logs (",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "YANDEX_API_KEY",
        "kind": 5,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "YANDEX_API_KEY = 'd839c21f-c590-43dc-a18b-f2e5c62baf8b'\ndef geocode_address(address: str) -> tuple[float, float] | None:\n    \"\"\"Получает координаты по адресу через Яндекс.Карты\"\"\"\n    url = f'https://geocode-maps.yandex.ru/1.x/?apikey={YANDEX_API_KEY}&geocode={address}&format=json'\n    resp = requests.get(url)\n    if resp.status_code == 200:\n        try:\n            pos = resp.json()['response']['GeoObjectCollection']['featureMember'][0]['GeoObject']['Point']['pos']\n            lon, lat = map(float, pos.split())\n            return lat, lon",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "BRAND_SYNONYMS",
        "kind": 5,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "BRAND_SYNONYMS = {\n    'bmw': ['bmw', 'бмв'],\n    'mercedes': ['mercedes', 'mercedes-benz', 'мерседес', 'мерседес-бенц'],\n    'audi': ['audi', 'ауди'],\n}\ndef is_brand_match(brand, target):\n    brand = normalize_str(brand)\n    target = normalize_str(target)\n    for canon, variants in BRAND_SYNONYMS.items():\n        if brand in variants and (target in variants or canon in target):",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "FILTER_VALUE_MAP",
        "kind": 5,
        "importPath": "database",
        "description": "database",
        "peekOfCode": "FILTER_VALUE_MAP = {\n    'fuel_type': {\n        'petrol': 'бензин',\n        'gasoline': 'бензин',\n        'diesel': 'дизель',\n        'hybrid': 'гибрид',\n        'электро': 'электрический',\n        'electric': 'электрический',\n        'электрический': 'электрический',\n        'бензин': 'бензин',",
        "detail": "database",
        "documentation": {}
    },
    {
        "label": "test_specific_query",
        "kind": 2,
        "importPath": "debug_error",
        "description": "debug_error",
        "peekOfCode": "def test_specific_query(query):\n    \"\"\"Тестирует конкретный запрос с детальным логированием\"\"\"\n    try:\n        from intelligent_query_processor import IntelligentQueryProcessor\n        from nlp_processor import NLPProcessor\n        print(f\"🔍 Тестируем запрос: '{query}'\")\n        # Инициализируем процессоры\n        nlp = NLPProcessor()\n        iqp = IntelligentQueryProcessor(nlp)\n        # Обрабатываем запрос",
        "detail": "debug_error",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "debug_error",
        "description": "debug_error",
        "peekOfCode": "def main():\n    \"\"\"Основная функция\"\"\"\n    # Тестируем проблемные запросы\n    test_queries = [\n        \"найди машины с открытой крышей\",\n        \"в каком месяце лучше всего собирать урожай покрышек\",\n        \"сможешь подобрать маленькую машину для одного человека?\",\n        \"нужен внедорожник\",\n        \"покажи электромобиль до 3 млн\"\n    ]",
        "detail": "debug_error",
        "documentation": {}
    },
    {
        "label": "test_car_parser_debug",
        "kind": 2,
        "importPath": "debug_parser",
        "description": "debug_parser",
        "peekOfCode": "def test_car_parser_debug():\n    \"\"\"Тестирует API парсера автомобилей с подробным логированием\"\"\"\n    # URL для тестирования\n    base_url = \"http://localhost:5000\"\n    # Получаем CSRF токен\n    print(\"🔑 Получаем CSRF токен...\")\n    try:\n        csrf_response = requests.get(f\"{base_url}/api/csrf-token\")\n        if csrf_response.status_code == 200:\n            csrf_data = csrf_response.json()",
        "detail": "debug_parser",
        "documentation": {}
    },
    {
        "label": "conn",
        "kind": 5,
        "importPath": "debug_query",
        "description": "debug_query",
        "peekOfCode": "conn = sqlite3.connect('instance/cars.db')\ncursor = conn.cursor()\nprint(\"=== Проверяем типы кузова ===\")\ncursor.execute('SELECT DISTINCT body_type, COUNT(*) FROM car GROUP BY body_type')\nprint('CAR table body_types:')\nfor row in cursor.fetchall():\n    print(f'{row[0]}: {row[1]}')\ncursor.execute('SELECT DISTINCT body_type, COUNT(*) FROM used_car GROUP BY body_type')\nprint('USED_CAR table body_types:')\nfor row in cursor.fetchall():",
        "detail": "debug_query",
        "documentation": {}
    },
    {
        "label": "cursor",
        "kind": 5,
        "importPath": "debug_query",
        "description": "debug_query",
        "peekOfCode": "cursor = conn.cursor()\nprint(\"=== Проверяем типы кузова ===\")\ncursor.execute('SELECT DISTINCT body_type, COUNT(*) FROM car GROUP BY body_type')\nprint('CAR table body_types:')\nfor row in cursor.fetchall():\n    print(f'{row[0]}: {row[1]}')\ncursor.execute('SELECT DISTINCT body_type, COUNT(*) FROM used_car GROUP BY body_type')\nprint('USED_CAR table body_types:')\nfor row in cursor.fetchall():\n    print(f'{row[0]}: {row[1]}')",
        "detail": "debug_query",
        "documentation": {}
    },
    {
        "label": "query",
        "kind": 5,
        "importPath": "debug_query",
        "description": "debug_query",
        "peekOfCode": "query = \"\"\"\nSELECT COUNT(*) FROM (\n    SELECT id, title, doc_num, mark, model, vin, color, price, city, manufacture_year, body_type, gear_box_type, driving_gear_type, engine_vol, power, fuel_type, dealer_center FROM car WHERE 1=1 AND price <= 2000000 AND LOWER(body_type) = 'внедорожник' AND LOWER(driving_gear_type) = 'полный'\n    UNION ALL \n    SELECT id, title, doc_num, mark, model, vin, color, price, city, manufacture_year, body_type, gear_box_type, driving_gear_type, engine_vol, power, fuel_type, dealer_center FROM used_car WHERE 1=1 AND price <= 2000000 AND LOWER(body_type) = 'внедорожник' AND LOWER(driving_gear_type) = 'полный'\n)\n\"\"\"\ncursor.execute(query)\nresult = cursor.fetchone()\nprint(f\"Результат запроса: {result[0]}\")",
        "detail": "debug_query",
        "documentation": {}
    },
    {
        "label": "result",
        "kind": 5,
        "importPath": "debug_query",
        "description": "debug_query",
        "peekOfCode": "result = cursor.fetchone()\nprint(f\"Результат запроса: {result[0]}\")\nprint(\"\\n=== Проверяем отдельно CAR table ===\")\ncursor.execute(\"SELECT COUNT(*) FROM car WHERE price <= 2000000 AND LOWER(body_type) = 'внедорожник' AND LOWER(driving_gear_type) = 'полный'\")\ncar_result = cursor.fetchone()\nprint(f\"CAR table: {car_result[0]}\")\nprint(\"\\n=== Проверяем отдельно USED_CAR table ===\")\ncursor.execute(\"SELECT COUNT(*) FROM used_car WHERE price <= 2000000 AND LOWER(body_type) = 'внедорожник' AND LOWER(driving_gear_type) = 'полный'\")\nused_result = cursor.fetchone()\nprint(f\"USED_CAR table: {used_result[0]}\")",
        "detail": "debug_query",
        "documentation": {}
    },
    {
        "label": "car_result",
        "kind": 5,
        "importPath": "debug_query",
        "description": "debug_query",
        "peekOfCode": "car_result = cursor.fetchone()\nprint(f\"CAR table: {car_result[0]}\")\nprint(\"\\n=== Проверяем отдельно USED_CAR table ===\")\ncursor.execute(\"SELECT COUNT(*) FROM used_car WHERE price <= 2000000 AND LOWER(body_type) = 'внедорожник' AND LOWER(driving_gear_type) = 'полный'\")\nused_result = cursor.fetchone()\nprint(f\"USED_CAR table: {used_result[0]}\")\nprint(\"\\n=== Проверяем только body_type ===\")\ncursor.execute(\"SELECT COUNT(*) FROM car WHERE LOWER(body_type) = 'внедорожник'\")\ncar_body = cursor.fetchone()\ncursor.execute(\"SELECT COUNT(*) FROM used_car WHERE LOWER(body_type) = 'внедорожник'\")",
        "detail": "debug_query",
        "documentation": {}
    },
    {
        "label": "used_result",
        "kind": 5,
        "importPath": "debug_query",
        "description": "debug_query",
        "peekOfCode": "used_result = cursor.fetchone()\nprint(f\"USED_CAR table: {used_result[0]}\")\nprint(\"\\n=== Проверяем только body_type ===\")\ncursor.execute(\"SELECT COUNT(*) FROM car WHERE LOWER(body_type) = 'внедорожник'\")\ncar_body = cursor.fetchone()\ncursor.execute(\"SELECT COUNT(*) FROM used_car WHERE LOWER(body_type) = 'внедорожник'\")\nused_body = cursor.fetchone()\nprint(f\"CAR table с body_type='внедорожник': {car_body[0]}\")\nprint(f\"USED_CAR table с body_type='внедорожник': {used_body[0]}\")\nprint(\"\\n=== Проверяем только driving_gear_type ===\")",
        "detail": "debug_query",
        "documentation": {}
    },
    {
        "label": "car_body",
        "kind": 5,
        "importPath": "debug_query",
        "description": "debug_query",
        "peekOfCode": "car_body = cursor.fetchone()\ncursor.execute(\"SELECT COUNT(*) FROM used_car WHERE LOWER(body_type) = 'внедорожник'\")\nused_body = cursor.fetchone()\nprint(f\"CAR table с body_type='внедорожник': {car_body[0]}\")\nprint(f\"USED_CAR table с body_type='внедорожник': {used_body[0]}\")\nprint(\"\\n=== Проверяем только driving_gear_type ===\")\ncursor.execute(\"SELECT COUNT(*) FROM car WHERE LOWER(driving_gear_type) = 'полный'\")\ncar_drive = cursor.fetchone()\ncursor.execute(\"SELECT COUNT(*) FROM used_car WHERE LOWER(driving_gear_type) = 'полный'\")\nused_drive = cursor.fetchone()",
        "detail": "debug_query",
        "documentation": {}
    },
    {
        "label": "used_body",
        "kind": 5,
        "importPath": "debug_query",
        "description": "debug_query",
        "peekOfCode": "used_body = cursor.fetchone()\nprint(f\"CAR table с body_type='внедорожник': {car_body[0]}\")\nprint(f\"USED_CAR table с body_type='внедорожник': {used_body[0]}\")\nprint(\"\\n=== Проверяем только driving_gear_type ===\")\ncursor.execute(\"SELECT COUNT(*) FROM car WHERE LOWER(driving_gear_type) = 'полный'\")\ncar_drive = cursor.fetchone()\ncursor.execute(\"SELECT COUNT(*) FROM used_car WHERE LOWER(driving_gear_type) = 'полный'\")\nused_drive = cursor.fetchone()\nprint(f\"CAR table с driving_gear_type='полный': {car_drive[0]}\")\nprint(f\"USED_CAR table с driving_gear_type='полный': {used_drive[0]}\")",
        "detail": "debug_query",
        "documentation": {}
    },
    {
        "label": "car_drive",
        "kind": 5,
        "importPath": "debug_query",
        "description": "debug_query",
        "peekOfCode": "car_drive = cursor.fetchone()\ncursor.execute(\"SELECT COUNT(*) FROM used_car WHERE LOWER(driving_gear_type) = 'полный'\")\nused_drive = cursor.fetchone()\nprint(f\"CAR table с driving_gear_type='полный': {car_drive[0]}\")\nprint(f\"USED_CAR table с driving_gear_type='полный': {used_drive[0]}\")\nconn.close()",
        "detail": "debug_query",
        "documentation": {}
    },
    {
        "label": "used_drive",
        "kind": 5,
        "importPath": "debug_query",
        "description": "debug_query",
        "peekOfCode": "used_drive = cursor.fetchone()\nprint(f\"CAR table с driving_gear_type='полный': {car_drive[0]}\")\nprint(f\"USED_CAR table с driving_gear_type='полный': {used_drive[0]}\")\nconn.close()",
        "detail": "debug_query",
        "documentation": {}
    },
    {
        "label": "DeepSeekService",
        "kind": 6,
        "importPath": "deepseek_service",
        "description": "deepseek_service",
        "peekOfCode": "class DeepSeekService:\n    def __init__(self):\n        self.api_url = self._find_working_api_url()\n        self.available = self._check_availability()\n        self.db_path = \"instance/cars.db\"\n    def _find_working_api_url(self) -> str:\n        \"\"\"Пробует несколько адресов DeepSeek и возвращает первый рабочий\"\"\"\n        urls = [\n            \"http://host.docker.internal:11888/v1/chat/completions\",\n            \"http://localhost:11888/v1/chat/completions\",",
        "detail": "deepseek_service",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "deepseek_service",
        "description": "deepseek_service",
        "peekOfCode": "logger = logging.getLogger(\"deepseek_service\")\nclass DeepSeekService:\n    def __init__(self):\n        self.api_url = self._find_working_api_url()\n        self.available = self._check_availability()\n        self.db_path = \"instance/cars.db\"\n    def _find_working_api_url(self) -> str:\n        \"\"\"Пробует несколько адресов DeepSeek и возвращает первый рабочий\"\"\"\n        urls = [\n            \"http://host.docker.internal:11888/v1/chat/completions\",",
        "detail": "deepseek_service",
        "documentation": {}
    },
    {
        "label": "deepseek_service",
        "kind": 5,
        "importPath": "deepseek_service",
        "description": "deepseek_service",
        "peekOfCode": "deepseek_service = DeepSeekService()",
        "detail": "deepseek_service",
        "documentation": {}
    },
    {
        "label": "DialogManager",
        "kind": 6,
        "importPath": "dialog_manager",
        "description": "dialog_manager",
        "peekOfCode": "class DialogManager:\n    def __init__(self):\n        self.cache = CacheManager()\n        self.nlp = NLPProcessor()\n    def handle_query(self, user_id: str, query: str) -> str:\n        try:\n            cached = self.cache.get_simple_cache(query)\n            if cached:\n                return cached\n            # Получение текущего контекста",
        "detail": "dialog_manager",
        "documentation": {}
    },
    {
        "label": "ContextAwareDialogManager",
        "kind": 6,
        "importPath": "dialog_manager",
        "description": "dialog_manager",
        "peekOfCode": "class ContextAwareDialogManager(DialogManager):\n    \"\"\"\n    Менеджер диалога с расширенным учётом контекста пользователя:\n    - анализирует историю запросов\n    - учитывает предпочтения пользователя\n    - может персонализировать ответы и рекомендации\n    \"\"\"\n    def __init__(self):\n        super().__init__()\n        self.user_history = UserHistory()",
        "detail": "dialog_manager",
        "documentation": {}
    },
    {
        "label": "get_model_synonyms_universal",
        "kind": 2,
        "importPath": "dialog_manager",
        "description": "dialog_manager",
        "peekOfCode": "def get_model_synonyms_universal(model):\n    if not model:\n        return []\n    key = str(model).lower().replace(' ', '')\n    for canon, syns in MODEL_SYNONYMS.items():\n        if key in [s.replace(' ', '') for s in syns]:\n            return syns\n    return [model]\nclass DialogManager:\n    def __init__(self):",
        "detail": "dialog_manager",
        "documentation": {}
    },
    {
        "label": "get_first",
        "kind": 2,
        "importPath": "dialog_manager",
        "description": "dialog_manager",
        "peekOfCode": "def get_first(val):\n    if isinstance(val, list):\n        return val[0] if val else None\n    if isinstance(val, tuple):\n        return val[0] if val else None\n    return val\nclass ContextAwareDialogManager(DialogManager):\n    \"\"\"\n    Менеджер диалога с расширенным учётом контекста пользователя:\n    - анализирует историю запросов",
        "detail": "dialog_manager",
        "documentation": {}
    },
    {
        "label": "MODEL_SYNONYMS",
        "kind": 5,
        "importPath": "dialog_manager",
        "description": "dialog_manager",
        "peekOfCode": "MODEL_SYNONYMS = {\n    # BMW\n    'x5': ['x5', '5 серии', '5 серия', '5 series'],\n    '5 серии': ['5 серии', '5 серия', 'x5', '5 series'],\n    '5 серия': ['5 серия', '5 серии', 'x5', '5 series'],\n    'x3': ['x3', '3 серии', '3 серия', '3 series'],\n    'x6': ['x6', '6 серии', '6 серия', '6 series'],\n    'x4': ['x4', '4 серии', '4 серия', '4 series'],\n    'x7': ['x7', '7 серии', '7 серия', '7 series'],\n    # Mercedes",
        "detail": "dialog_manager",
        "documentation": {}
    },
    {
        "label": "get_table_columns",
        "kind": 2,
        "importPath": "extract_all_columns",
        "description": "extract_all_columns",
        "peekOfCode": "def get_table_columns(db_path, table_name):\n    \"\"\"Получает информацию о столбцах таблицы\"\"\"\n    conn = sqlite3.connect(db_path)\n    cursor = conn.cursor()\n    try:\n        # Получаем информацию о столбцах\n        cursor.execute(f\"PRAGMA table_info({table_name})\")\n        columns_info = cursor.fetchall()\n        columns = []\n        for col in columns_info:",
        "detail": "extract_all_columns",
        "documentation": {}
    },
    {
        "label": "get_sample_data",
        "kind": 2,
        "importPath": "extract_all_columns",
        "description": "extract_all_columns",
        "peekOfCode": "def get_sample_data(db_path, table_name, limit=3):\n    \"\"\"Получает образцы данных из таблицы\"\"\"\n    conn = sqlite3.connect(db_path)\n    cursor = conn.cursor()\n    try:\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        rows = cursor.fetchall()\n        # Получаем названия столбцов\n        cursor.execute(f\"PRAGMA table_info({table_name})\")\n        columns = [col[1] for col in cursor.fetchall()]",
        "detail": "extract_all_columns",
        "documentation": {}
    },
    {
        "label": "list_tables",
        "kind": 2,
        "importPath": "extract_all_columns",
        "description": "extract_all_columns",
        "peekOfCode": "def list_tables(db_path):\n    conn = sqlite3.connect(db_path)\n    cursor = conn.cursor()\n    cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' ORDER BY name;\")\n    tables = [row[0] for row in cursor.fetchall()]\n    conn.close()\n    return tables\ndef main():\n    db_path = \"instance/cars.db\"\n    tables = [",
        "detail": "extract_all_columns",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "extract_all_columns",
        "description": "extract_all_columns",
        "peekOfCode": "def main():\n    db_path = \"instance/cars.db\"\n    tables = [\n        \"car\",\n        \"option\",\n        \"option_group\",\n        \"picture\",\n        \"trends\",\n        \"used_car\",\n        \"used_car_picture\"",
        "detail": "extract_all_columns",
        "documentation": {}
    },
    {
        "label": "extract_unique_values",
        "kind": 2,
        "importPath": "extract_unique_values",
        "description": "extract_unique_values",
        "peekOfCode": "def extract_unique_values():\n    \"\"\"Извлекает уникальные значения из таблиц car и used_car\"\"\"\n    conn = sqlite3.connect(DB_PATH)\n    cursor = conn.cursor()\n    # Список таблиц для анализа\n    tables = ['car', 'used_car']\n    # Словарь для хранения результатов\n    unique_values = {}\n    for table in tables:\n        try:",
        "detail": "extract_unique_values",
        "documentation": {}
    },
    {
        "label": "get_body_type_stats",
        "kind": 2,
        "importPath": "extract_unique_values",
        "description": "extract_unique_values",
        "peekOfCode": "def get_body_type_stats():\n    conn = sqlite3.connect(DB_PATH)\n    cursor = conn.cursor()\n    body_type_counts = defaultdict(int)\n    for table in ['car', 'used_car']:\n        try:\n            cursor.execute(f\"SELECT body_type FROM {table}\")\n            rows = cursor.fetchall()\n            for row in rows:\n                if row[0]:",
        "detail": "extract_unique_values",
        "documentation": {}
    },
    {
        "label": "DB_PATH",
        "kind": 5,
        "importPath": "extract_unique_values",
        "description": "extract_unique_values",
        "peekOfCode": "DB_PATH = 'instance/cars.db'\ndef extract_unique_values():\n    \"\"\"Извлекает уникальные значения из таблиц car и used_car\"\"\"\n    conn = sqlite3.connect(DB_PATH)\n    cursor = conn.cursor()\n    # Список таблиц для анализа\n    tables = ['car', 'used_car']\n    # Словарь для хранения результатов\n    unique_values = {}\n    for table in tables:",
        "detail": "extract_unique_values",
        "documentation": {}
    },
    {
        "label": "get_first_deep",
        "kind": 2,
        "importPath": "filter_mapping",
        "description": "filter_mapping",
        "peekOfCode": "def get_first_deep(val):\n    if isinstance(val, (list, tuple)):\n        return get_first_deep(val[0]) if val else None\n    return val\ndef map_filter_value(field, value):\n    \"\"\"Преобразует русское значение фильтра к значению в БД\"\"\"\n    value = get_first_deep(value)\n    if value is None:\n        return value\n    if field == 'fuel_type':",
        "detail": "filter_mapping",
        "documentation": {}
    },
    {
        "label": "map_filter_value",
        "kind": 2,
        "importPath": "filter_mapping",
        "description": "filter_mapping",
        "peekOfCode": "def map_filter_value(field, value):\n    \"\"\"Преобразует русское значение фильтра к значению в БД\"\"\"\n    value = get_first_deep(value)\n    if value is None:\n        return value\n    if field == 'fuel_type':\n        return FUEL_TYPE_MAP.get(value.lower(), value)\n    if field == 'gear_box_type':\n        return GEAR_BOX_TYPE_MAP.get(value.lower(), value)\n    if field == 'body_type':",
        "detail": "filter_mapping",
        "documentation": {}
    },
    {
        "label": "FUEL_TYPE_MAP",
        "kind": 5,
        "importPath": "filter_mapping",
        "description": "filter_mapping",
        "peekOfCode": "FUEL_TYPE_MAP = {\n    'бензин': 'бензин',\n    'дизель': 'дизель',\n    'гибрид': 'гибрид',\n    'электро': '',  # если появится — добавить\n}\nGEAR_BOX_TYPE_MAP = {\n    'автомат': 'автомат',\n    'механика': 'механика',\n    'ручная': 'механика',",
        "detail": "filter_mapping",
        "documentation": {}
    },
    {
        "label": "GEAR_BOX_TYPE_MAP",
        "kind": 5,
        "importPath": "filter_mapping",
        "description": "filter_mapping",
        "peekOfCode": "GEAR_BOX_TYPE_MAP = {\n    'автомат': 'автомат',\n    'механика': 'механика',\n    'ручная': 'механика',\n}\nBODY_TYPE_MAP = {\n    'внедорожник': 'Внедорожник',\n    'кроссовер': 'Кроссовер',\n    'купе-кроссовер': 'Купе-кроссовер',\n    'лифтбэк': 'Лифтбэк',",
        "detail": "filter_mapping",
        "documentation": {}
    },
    {
        "label": "BODY_TYPE_MAP",
        "kind": 5,
        "importPath": "filter_mapping",
        "description": "filter_mapping",
        "peekOfCode": "BODY_TYPE_MAP = {\n    'внедорожник': 'Внедорожник',\n    'кроссовер': 'Кроссовер',\n    'купе-кроссовер': 'Купе-кроссовер',\n    'лифтбэк': 'Лифтбэк',\n    'минивэн': 'Минивэн',\n    'пикап': 'Пикап',\n    'седан': 'Седан',\n    'универсал': 'Универсал',\n    'хетчбек': 'Хетчбэк',",
        "detail": "filter_mapping",
        "documentation": {}
    },
    {
        "label": "DRIVE_TYPE_MAP",
        "kind": 5,
        "importPath": "filter_mapping",
        "description": "filter_mapping",
        "peekOfCode": "DRIVE_TYPE_MAP = {\n    'передний': 'передний',\n    'полный': 'полный',\n    'задний': '',  # если появится — добавить\n}\ndef get_first_deep(val):\n    if isinstance(val, (list, tuple)):\n        return get_first_deep(val[0]) if val else None\n    return val\ndef map_filter_value(field, value):",
        "detail": "filter_mapping",
        "documentation": {}
    },
    {
        "label": "DB_PATH",
        "kind": 5,
        "importPath": "find_cities",
        "description": "find_cities",
        "peekOfCode": "DB_PATH = 'instance/cars.db'\nconn = sqlite3.connect(DB_PATH)\ncursor = conn.cursor()\ncities = set()\nfor table in ['car', 'used_car']:\n    try:\n        cursor.execute(f'SELECT DISTINCT city FROM {table}')\n        for row in cursor.fetchall():\n            city = row[0]\n            if city and city.strip():",
        "detail": "find_cities",
        "documentation": {}
    },
    {
        "label": "conn",
        "kind": 5,
        "importPath": "find_cities",
        "description": "find_cities",
        "peekOfCode": "conn = sqlite3.connect(DB_PATH)\ncursor = conn.cursor()\ncities = set()\nfor table in ['car', 'used_car']:\n    try:\n        cursor.execute(f'SELECT DISTINCT city FROM {table}')\n        for row in cursor.fetchall():\n            city = row[0]\n            if city and city.strip():\n                cities.add(city.strip())",
        "detail": "find_cities",
        "documentation": {}
    },
    {
        "label": "cursor",
        "kind": 5,
        "importPath": "find_cities",
        "description": "find_cities",
        "peekOfCode": "cursor = conn.cursor()\ncities = set()\nfor table in ['car', 'used_car']:\n    try:\n        cursor.execute(f'SELECT DISTINCT city FROM {table}')\n        for row in cursor.fetchall():\n            city = row[0]\n            if city and city.strip():\n                cities.add(city.strip())\n    except Exception as e:",
        "detail": "find_cities",
        "documentation": {}
    },
    {
        "label": "cities",
        "kind": 5,
        "importPath": "find_cities",
        "description": "find_cities",
        "peekOfCode": "cities = set()\nfor table in ['car', 'used_car']:\n    try:\n        cursor.execute(f'SELECT DISTINCT city FROM {table}')\n        for row in cursor.fetchall():\n            city = row[0]\n            if city and city.strip():\n                cities.add(city.strip())\n    except Exception as e:\n        print(f'Ошибка при чтении {table}:', e)",
        "detail": "find_cities",
        "documentation": {}
    },
    {
        "label": "check_ml_models",
        "kind": 2,
        "importPath": "fix_ml_models",
        "description": "fix_ml_models",
        "peekOfCode": "def check_ml_models():\n    \"\"\"Проверяет состояние ML моделей\"\"\"\n    models_dir = Path(\"ml_models\")\n    if not models_dir.exists():\n        logger.info(\"Директория ml_models не существует\")\n        return False\n    model_files = [\n        'intent_classifier.pkl',\n        'sentiment_classifier.pkl', \n        'car_clusterer.pkl',",
        "detail": "fix_ml_models",
        "documentation": {}
    },
    {
        "label": "backup_ml_models",
        "kind": 2,
        "importPath": "fix_ml_models",
        "description": "fix_ml_models",
        "peekOfCode": "def backup_ml_models():\n    \"\"\"Создает резервную копию ML моделей\"\"\"\n    models_dir = Path(\"ml_models\")\n    backup_dir = Path(\"ml_models_backup\")\n    if not models_dir.exists():\n        logger.info(\"Директория ml_models не существует, резервная копия не нужна\")\n        return\n    try:\n        # Удаляем старую резервную копию если есть\n        if backup_dir.exists():",
        "detail": "fix_ml_models",
        "documentation": {}
    },
    {
        "label": "clean_ml_models",
        "kind": 2,
        "importPath": "fix_ml_models",
        "description": "fix_ml_models",
        "peekOfCode": "def clean_ml_models():\n    \"\"\"Очищает поврежденные ML модели\"\"\"\n    models_dir = Path(\"ml_models\")\n    if not models_dir.exists():\n        logger.info(\"Директория ml_models не существует\")\n        return\n    model_files = [\n        'intent_classifier.pkl',\n        'sentiment_classifier.pkl', \n        'car_clusterer.pkl',",
        "detail": "fix_ml_models",
        "documentation": {}
    },
    {
        "label": "recreate_ml_models",
        "kind": 2,
        "importPath": "fix_ml_models",
        "description": "fix_ml_models",
        "peekOfCode": "def recreate_ml_models():\n    \"\"\"Пересоздает ML модели\"\"\"\n    logger.info(\"🔄 Пересоздание ML моделей...\")\n    try:\n        # Импортируем NLPProcessor\n        from nlp_processor import NLPProcessor\n        # Создаем новый экземпляр (это пересоздаст модели)\n        nlp = NLPProcessor()\n        logger.info(\"✅ ML модели успешно пересозданы\")\n        return True",
        "detail": "fix_ml_models",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "fix_ml_models",
        "description": "fix_ml_models",
        "peekOfCode": "def main():\n    \"\"\"Основная функция\"\"\"\n    print(\"🔧 Исправление ML моделей\")\n    print(\"=\" * 40)\n    # Проверяем текущее состояние\n    if check_ml_models():\n        print(\"✅ Все ML модели в порядке!\")\n        return\n    print(\"\\n⚠️ Обнаружены проблемы с ML моделями\")\n    # Спрашиваем пользователя",
        "detail": "fix_ml_models",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "fix_ml_models",
        "description": "fix_ml_models",
        "peekOfCode": "logger = logging.getLogger(__name__)\ndef check_ml_models():\n    \"\"\"Проверяет состояние ML моделей\"\"\"\n    models_dir = Path(\"ml_models\")\n    if not models_dir.exists():\n        logger.info(\"Директория ml_models не существует\")\n        return False\n    model_files = [\n        'intent_classifier.pkl',\n        'sentiment_classifier.pkl', ",
        "detail": "fix_ml_models",
        "documentation": {}
    },
    {
        "label": "check_psutil",
        "kind": 2,
        "importPath": "fix_psutil",
        "description": "fix_psutil",
        "peekOfCode": "def check_psutil():\n    \"\"\"Проверяет, установлен ли psutil\"\"\"\n    try:\n        import psutil\n        print(f\"✅ psutil установлен (версия: {psutil.__version__})\")\n        return True\n    except ImportError:\n        print(\"❌ psutil не установлен\")\n        return False\ndef install_psutil():",
        "detail": "fix_psutil",
        "documentation": {}
    },
    {
        "label": "install_psutil",
        "kind": 2,
        "importPath": "fix_psutil",
        "description": "fix_psutil",
        "peekOfCode": "def install_psutil():\n    \"\"\"Пытается установить psutil разными способами\"\"\"\n    print(\"🔧 Попытка установки psutil...\")\n    commands = [\n        [sys.executable, \"-m\", \"pip\", \"install\", \"psutil==5.9.6\"],\n        [\"pip\", \"install\", \"psutil==5.9.6\"],\n        [sys.executable, \"-m\", \"pip\", \"install\", \"--user\", \"psutil==5.9.6\"],\n        [sys.executable, \"-m\", \"pip\", \"install\", \"--force-reinstall\", \"psutil==5.9.6\"]\n    ]\n    for i, cmd in enumerate(commands, 1):",
        "detail": "fix_psutil",
        "documentation": {}
    },
    {
        "label": "create_backup_files",
        "kind": 2,
        "importPath": "fix_psutil",
        "description": "fix_psutil",
        "peekOfCode": "def create_backup_files():\n    \"\"\"Создает резервные копии файлов с psutil\"\"\"\n    files_to_backup = [\n        (\"monitoring.py\", \"monitoring_backup.py\"),\n        (\"start_system.py\", \"start_system_backup.py\")\n    ]\n    for original, backup in files_to_backup:\n        if os.path.exists(original):\n            try:\n                shutil.copy2(original, backup)",
        "detail": "fix_psutil",
        "documentation": {}
    },
    {
        "label": "replace_with_no_psutil_versions",
        "kind": 2,
        "importPath": "fix_psutil",
        "description": "fix_psutil",
        "peekOfCode": "def replace_with_no_psutil_versions():\n    \"\"\"Заменяет файлы на версии без psutil\"\"\"\n    replacements = [\n        (\"monitoring_no_psutil.py\", \"monitoring.py\"),\n        (\"start_system_no_psutil.py\", \"start_system.py\")\n    ]\n    for source, target in replacements:\n        if os.path.exists(source):\n            try:\n                # Создаем резервную копию оригинального файла",
        "detail": "fix_psutil",
        "documentation": {}
    },
    {
        "label": "restore_original_files",
        "kind": 2,
        "importPath": "fix_psutil",
        "description": "fix_psutil",
        "peekOfCode": "def restore_original_files():\n    \"\"\"Восстанавливает оригинальные файлы\"\"\"\n    restorations = [\n        (\"monitoring_backup.py\", \"monitoring.py\"),\n        (\"start_system_backup.py\", \"start_system.py\")\n    ]\n    for backup, original in restorations:\n        if os.path.exists(backup):\n            try:\n                shutil.copy2(backup, original)",
        "detail": "fix_psutil",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "fix_psutil",
        "description": "fix_psutil",
        "peekOfCode": "def main():\n    \"\"\"Основная функция\"\"\"\n    print(\"🔧 ИСПРАВЛЕНИЕ ПРОБЛЕМ С PSUTIL\")\n    print(\"=\" * 40)\n    # Проверяем текущее состояние\n    if check_psutil():\n        print(\"🎉 psutil уже установлен! Проблем нет.\")\n        return True\n    print(\"\\n📋 Доступные варианты решения:\")\n    print(\"1. Попытаться установить psutil\")",
        "detail": "fix_psutil",
        "documentation": {}
    },
    {
        "label": "FuzzySearch",
        "kind": 6,
        "importPath": "fuzzy_search",
        "description": "fuzzy_search",
        "peekOfCode": "class FuzzySearch:\n    \"\"\"Класс для нечёткого поиска и исправления опечаток\"\"\"\n    def __init__(self):\n        # Убраны дубликаты брендов\n        self.brand_synonyms = {\n            'bmw': ['бмв', 'бмвв', 'bmvv', 'bmw'],\n            'mercedes': ['мерседес', 'мерс', 'mercedes-benz', 'benz', 'мерседес-бенц'],\n            'audi': ['ауди', 'аудии', 'audii'],\n            'toyota': ['тойота', 'тойотта', 'toyotaa'],\n            'honda': ['хонда', 'хондда', 'hondaa'],",
        "detail": "fuzzy_search",
        "documentation": {}
    },
    {
        "label": "fuzzy_search",
        "kind": 5,
        "importPath": "fuzzy_search",
        "description": "fuzzy_search",
        "peekOfCode": "fuzzy_search = FuzzySearch()",
        "detail": "fuzzy_search",
        "documentation": {}
    },
    {
        "label": "install_dependencies",
        "kind": 2,
        "importPath": "install_dependencies",
        "description": "install_dependencies",
        "peekOfCode": "def install_dependencies():\n    \"\"\"Устанавливает все зависимости из requirements.txt\"\"\"\n    print(\"Установка зависимостей...\")\n    try:\n        # Устанавливаем зависимости\n        result = subprocess.run([\n            sys.executable, \"-m\", \"pip\", \"install\", \"-r\", \"requirements.txt\"\n        ], capture_output=True, text=True, check=True)\n        print(\"✅ Зависимости успешно установлены!\")\n        print(result.stdout)",
        "detail": "install_dependencies",
        "documentation": {}
    },
    {
        "label": "check_psutil",
        "kind": 2,
        "importPath": "install_dependencies",
        "description": "install_dependencies",
        "peekOfCode": "def check_psutil():\n    \"\"\"Проверяет, установлен ли psutil\"\"\"\n    try:\n        import psutil\n        print(f\"✅ psutil установлен (версия: {psutil.__version__})\")\n        return True\n    except ImportError:\n        print(\"❌ psutil не установлен\")\n        return False\nif __name__ == \"__main__\":",
        "detail": "install_dependencies",
        "documentation": {}
    },
    {
        "label": "install_psutil",
        "kind": 2,
        "importPath": "install_psutil",
        "description": "install_psutil",
        "peekOfCode": "def install_psutil():\n    \"\"\"Устанавливает psutil\"\"\"\n    print(\"Установка psutil...\")\n    try:\n        # Пробуем разные способы установки\n        commands = [\n            [sys.executable, \"-m\", \"pip\", \"install\", \"psutil==5.9.6\"],\n            [\"pip\", \"install\", \"psutil==5.9.6\"],\n            [sys.executable, \"-m\", \"pip\", \"install\", \"--user\", \"psutil==5.9.6\"]\n        ]",
        "detail": "install_psutil",
        "documentation": {}
    },
    {
        "label": "check_psutil",
        "kind": 2,
        "importPath": "install_psutil",
        "description": "install_psutil",
        "peekOfCode": "def check_psutil():\n    \"\"\"Проверяет установку psutil\"\"\"\n    try:\n        import psutil\n        print(f\"✅ psutil установлен (версия: {psutil.__version__})\")\n        return True\n    except ImportError:\n        print(\"❌ psutil не установлен\")\n        return False\nif __name__ == \"__main__\":",
        "detail": "install_psutil",
        "documentation": {}
    },
    {
        "label": "IntelligentQueryProcessor",
        "kind": 6,
        "importPath": "intelligent_query_processor",
        "description": "intelligent_query_processor",
        "peekOfCode": "class IntelligentQueryProcessor:\n    \"\"\"Умный обработчик запросов, использующий NLP и данные из БД\"\"\"\n    def __init__(self, nlp_processor):\n        self.nlp = nlp_processor\n        self.ollama_urls = [\n            \"http://localhost:11434/api/generate\",\n            \"http://127.0.0.1:11434/api/generate\",\n            \"http://host.docker.internal:11434/api/generate\",\n            \"http://localhost:11888/api/generate\",\n            \"http://127.0.0.1:11888/api/generate\",",
        "detail": "intelligent_query_processor",
        "documentation": {}
    },
    {
        "label": "get_first_deep",
        "kind": 2,
        "importPath": "intelligent_query_processor",
        "description": "intelligent_query_processor",
        "peekOfCode": "def get_first_deep(val):\n    if isinstance(val, (list, tuple)):\n        return get_first_deep(val[0]) if val else None\n    return val\nclass IntelligentQueryProcessor:\n    \"\"\"Умный обработчик запросов, использующий NLP и данные из БД\"\"\"\n    def __init__(self, nlp_processor):\n        self.nlp = nlp_processor\n        self.ollama_urls = [\n            \"http://localhost:11434/api/generate\",",
        "detail": "intelligent_query_processor",
        "documentation": {}
    },
    {
        "label": "get_car_advantages",
        "kind": 2,
        "importPath": "intelligent_query_processor",
        "description": "intelligent_query_processor",
        "peekOfCode": "def get_car_advantages(car):\n    \"\"\"\n    Определяет преимущества (advantages) для автомобиля на основе его характеристик.\n    Возвращает список преимуществ (строк).\n    \"\"\"\n    advantages = []\n    # Престиж\n    premium_brands = {'bmw', 'mercedes', 'audi', 'lexus', 'volvo', 'land rover', 'porsche', 'infiniti', 'cadillac', 'tesla', 'jaguar', 'acura'}\n    if str(car.get('mark', '')).strip().lower() in premium_brands:\n        advantages.append('Престиж')",
        "detail": "intelligent_query_processor",
        "documentation": {}
    },
    {
        "label": "postprocess_llama_response",
        "kind": 2,
        "importPath": "llama_service",
        "description": "llama_service",
        "peekOfCode": "def postprocess_llama_response(text):\n    \"\"\"\n    Заменяет коды опций вида `optXXXX` на их описания из базы.\n    \"\"\"\n    import re\n    from database import get_all_options\n    options = get_all_options()\n    code2desc = {o['code']: o['description'] for o in options if o['code']}\n    def repl(match):\n        code = match.group(1)",
        "detail": "llama_service",
        "documentation": {}
    },
    {
        "label": "generate_with_llama",
        "kind": 2,
        "importPath": "llama_service",
        "description": "llama_service",
        "peekOfCode": "def generate_with_llama(prompt: str, context: Optional[Dict] = None) -> str:\n    \"\"\"Генерирует ответ с помощью Llama\"\"\"\n    try:\n        url = _find_working_ollama_url()\n        payload = {\n            \"model\": \"llama3:8b\",\n            \"prompt\": prompt,\n            \"stream\": False\n        }\n        if context:",
        "detail": "llama_service",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "llama_service",
        "description": "llama_service",
        "peekOfCode": "logger = logging.getLogger(\"llama_service\")\ndef _find_working_ollama_url() -> str:\n    \"\"\"Пробует несколько адресов Ollama и возвращает первый рабочий\"\"\"\n    urls = [\n        \"http://localhost:11434/api/generate\",\n        \"http://127.0.0.1:11434/api/generate\",\n        \"http://host.docker.internal:11434/api/generate\",\n        \"http://localhost:11888/api/generate\",\n        \"http://127.0.0.1:11888/api/generate\",\n        \"http://host.docker.internal:11888/api/generate\",",
        "detail": "llama_service",
        "documentation": {}
    },
    {
        "label": "load_deepseek_model",
        "kind": 2,
        "importPath": "load_deepseek_model",
        "description": "load_deepseek_model",
        "peekOfCode": "def load_deepseek_model():\n    \"\"\"Загружает модель deepseek-r1:latest\"\"\"\n    print(\"=== ЗАГРУЗКА МОДЕЛИ DEEPSEEK-R1 ===\")\n    # Проверяем текущие модели\n    try:\n        print(\"1. Проверяем текущие модели...\")\n        response = requests.get(\"http://localhost:11888/api/tags\", timeout=10)\n        if response.status_code == 200:\n            models = response.json()\n            print(f\"   Доступные модели: {models}\")",
        "detail": "load_deepseek_model",
        "documentation": {}
    },
    {
        "label": "test_model_after_load",
        "kind": 2,
        "importPath": "load_deepseek_model",
        "description": "load_deepseek_model",
        "peekOfCode": "def test_model_after_load():\n    \"\"\"Тестирует модель после загрузки\"\"\"\n    print(\"\\n3. Тестируем загруженную модель...\")\n    try:\n        payload = {\n            \"model\": \"deepseek-r1:latest\",\n            \"prompt\": \"Привет! Как дела?\",\n            \"temperature\": 0.7,\n            \"max_tokens\": 50\n        }",
        "detail": "load_deepseek_model",
        "documentation": {}
    },
    {
        "label": "SystemMonitor",
        "kind": 6,
        "importPath": "monitoring",
        "description": "monitoring",
        "peekOfCode": "class SystemMonitor:\n    \"\"\"Мониторинг системы и производительности\"\"\"\n    def __init__(self, db_path: str = \"instance/cars.db\"):\n        self.db_path = db_path\n        self.setup_logging()\n    def setup_logging(self):\n        \"\"\"Настройка логирования\"\"\"\n        logging.basicConfig(\n            level=logging.INFO,\n            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',",
        "detail": "monitoring",
        "documentation": {}
    },
    {
        "label": "monitor_performance",
        "kind": 2,
        "importPath": "monitoring",
        "description": "monitoring",
        "peekOfCode": "def monitor_performance(func):\n    \"\"\"Декоратор для мониторинга производительности функций\"\"\"\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        start_time = time.time()\n        try:\n            result = func(*args, **kwargs)\n            response_time = (time.time() - start_time) * 1000  # в миллисекундах\n            return result\n        except Exception as e:",
        "detail": "monitoring",
        "documentation": {}
    },
    {
        "label": "log_api_call",
        "kind": 2,
        "importPath": "monitoring",
        "description": "monitoring",
        "peekOfCode": "def log_api_call(endpoint: str, user_id: Optional[str] = None):\n    \"\"\"Декоратор для логирования API вызовов\"\"\"\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            start_time = time.time()\n            try:\n                result = func(*args, **kwargs)\n                response_time = (time.time() - start_time) * 1000\n                # Логируем успешный запрос",
        "detail": "monitoring",
        "documentation": {}
    },
    {
        "label": "system_monitor",
        "kind": 5,
        "importPath": "monitoring",
        "description": "monitoring",
        "peekOfCode": "system_monitor = SystemMonitor()",
        "detail": "monitoring",
        "documentation": {}
    },
    {
        "label": "SystemMonitor",
        "kind": 6,
        "importPath": "monitoring_no_psutil",
        "description": "monitoring_no_psutil",
        "peekOfCode": "class SystemMonitor:\n    \"\"\"Монитор системы без psutil\"\"\"\n    def __init__(self):\n        self.start_time = time.time()\n        self.metrics = {}\n    def get_basic_metrics(self) -> Dict[str, Any]:\n        \"\"\"Получение базовых метрик без psutil\"\"\"\n        try:\n            # Время работы\n            uptime = time.time() - self.start_time",
        "detail": "monitoring_no_psutil",
        "documentation": {}
    },
    {
        "label": "monitor_system",
        "kind": 2,
        "importPath": "monitoring_no_psutil",
        "description": "monitoring_no_psutil",
        "peekOfCode": "def monitor_system(interval: int = 60, duration: Optional[int] = None):\n    \"\"\"Мониторинг системы\"\"\"\n    monitor = SystemMonitor()\n    start_time = time.time()\n    logger.info(\"Запуск мониторинга системы...\")\n    try:\n        while True:\n            # Проверяем время работы\n            if duration and (time.time() - start_time) > duration:\n                logger.info(\"Мониторинг завершен по времени\")",
        "detail": "monitoring_no_psutil",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "monitoring_no_psutil",
        "description": "monitoring_no_psutil",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass SystemMonitor:\n    \"\"\"Монитор системы без psutil\"\"\"\n    def __init__(self):\n        self.start_time = time.time()\n        self.metrics = {}\n    def get_basic_metrics(self) -> Dict[str, Any]:\n        \"\"\"Получение базовых метрик без psutil\"\"\"\n        try:\n            # Время работы",
        "detail": "monitoring_no_psutil",
        "documentation": {}
    },
    {
        "label": "NLPProcessor",
        "kind": 6,
        "importPath": "nlp_processor",
        "description": "nlp_processor",
        "peekOfCode": "class NLPProcessor:\n    \"\"\"Расширенный NLP процессор с ML и rule-based подходами\"\"\"\n    def __init__(self, models_dir: str = \"ml_models\"):\n        self.models_dir = models_dir\n        os.makedirs(models_dir, exist_ok=True)\n        # Инициализация ML моделей\n        self.intent_classifier = None\n        self.sentiment_classifier = None\n        self.car_clusterer = None\n        self.vectorizer = None",
        "detail": "nlp_processor",
        "documentation": {}
    },
    {
        "label": "get_first_deep",
        "kind": 2,
        "importPath": "nlp_processor",
        "description": "nlp_processor",
        "peekOfCode": "def get_first_deep(val):\n    if isinstance(val, (list, tuple)):\n        return get_first_deep(val[0]) if val else None\n    return val\n# --- Расширенная нормализация бренда ---\ndef normalize_brand_nlp(brand):\n    \"\"\"\n    Нормализует название бренда, используя расширенную систему словарей.\n    \"\"\"\n    if not brand:",
        "detail": "nlp_processor",
        "documentation": {}
    },
    {
        "label": "normalize_brand_nlp",
        "kind": 2,
        "importPath": "nlp_processor",
        "description": "nlp_processor",
        "peekOfCode": "def normalize_brand_nlp(brand):\n    \"\"\"\n    Нормализует название бренда, используя расширенную систему словарей.\n    \"\"\"\n    if not brand:\n        return None\n    # Используем новую функцию нормализации\n    return normalize_brand_extended(brand)\n# --- Нормализация моделей китайских брендов ---\ndef normalize_chinese_model(model, brand=None):",
        "detail": "nlp_processor",
        "documentation": {}
    },
    {
        "label": "normalize_chinese_model",
        "kind": 2,
        "importPath": "nlp_processor",
        "description": "nlp_processor",
        "peekOfCode": "def normalize_chinese_model(model, brand=None):\n    \"\"\"\n    Нормализует название модели, особенно для китайских брендов.\n    \"\"\"\n    if not model:\n        return None\n    model_lower = model.strip().lower()\n    # Сначала ищем в словаре синонимов моделей\n    if model_lower in CHINESE_MODEL_SYNONYMS:\n        return CHINESE_MODEL_SYNONYMS[model_lower]",
        "detail": "nlp_processor",
        "documentation": {}
    },
    {
        "label": "analyze_query",
        "kind": 2,
        "importPath": "nlp_processor",
        "description": "nlp_processor",
        "peekOfCode": "def analyze_query(user_message):\n    \"\"\"\n    Анализирует пользовательский запрос и извлекает интенты и сущности.\n    Возвращает: (intent, entities, need_clarification, clarification_questions)\n    \"\"\"\n    message_lower = user_message.lower()\n    # Определяем интент\n    intent = 'general'\n    # Ключевые слова для определения интентов\n    if any(word in message_lower for word in ['цена', 'стоимость', 'сколько стоит', 'почём', 'ценник']):",
        "detail": "nlp_processor",
        "documentation": {}
    },
    {
        "label": "extract_entities_from_text",
        "kind": 2,
        "importPath": "nlp_processor",
        "description": "nlp_processor",
        "peekOfCode": "def extract_entities_from_text(text):\n    \"\"\"\n    Извлекает сущности (бренд, модель, год и т.д.) из текста.\n    Исправлено: цвета извлекаются строго и не попадают в модель.\n    \"\"\"\n    import re\n    entities = {}\n    text_lower = text.lower()\n    # Очищаем текст от пунктуации для поиска цветов\n    text_clean = re.sub(r'[.,!?;:]', ' ', text_lower)",
        "detail": "nlp_processor",
        "documentation": {}
    },
    {
        "label": "extract_brand_from_text",
        "kind": 2,
        "importPath": "nlp_processor",
        "description": "nlp_processor",
        "peekOfCode": "def extract_brand_from_text(text: str) -> Optional[str]:\n    \"\"\"Извлекает бренд автомобиля из текста\"\"\"\n    if not text:\n        return None\n    text_lower = text.lower()\n    print(f\"[DEBUG] extract_brand_from_text: '{text}'\")\n    # Слова, которые НЕ являются брендами\n    exclude_words = {\n        'внедорожники', 'внедорожник', 'кроссовер', 'кроссоверы',\n        'седан', 'седаны', 'хэтчбек', 'хэтчбеки', 'универсал', 'универсалы',",
        "detail": "nlp_processor",
        "documentation": {}
    },
    {
        "label": "extract_model_from_text",
        "kind": 2,
        "importPath": "nlp_processor",
        "description": "nlp_processor",
        "peekOfCode": "def extract_model_from_text(text, brand=None):\n    \"\"\"\n    Извлекает модель из текста (после бренда или как второе слово).\n    Теперь исключает попадание в model любых слов, которые являются цветами, кузовами, характеристиками, служебными словами, а также любых слов, не являющихся реальными моделями из базы.\n    \"\"\"\n    import re\n    # Стоп-слова, которые не могут быть моделью\n    stop_words = {\n        'до', 'от', 'за', 'по', 'или', 'и', 'с', 'на', 'в', 'под', 'для', 'к', 'у', 'о', 'об', 'про', 'без', 'при', 'над', 'из', 'под', 'через', 'после', 'перед', 'между',\n        'внедорожник', 'внедорожники', 'кроссовер', 'кроссоверы', 'седан', 'седаны', 'универсал', 'универсалы', 'купе', 'кабриолет', 'пикап', 'минивэн', 'лифтбэк', 'хэтчбек', 'хэтчбеки',",
        "detail": "nlp_processor",
        "documentation": {}
    },
    {
        "label": "normalize_text",
        "kind": 2,
        "importPath": "nlp_processor",
        "description": "nlp_processor",
        "peekOfCode": "def normalize_text(text):\n    words = text.lower().split()\n    normalized = []\n    for word in words:\n        if word in BRAND_SYNONYMS:\n            normalized.append(BRAND_SYNONYMS[word])\n        else:\n            normalized.append(word)\n    return ' '.join(normalized)\ndef extract_feature_value(text, feature_word):",
        "detail": "nlp_processor",
        "documentation": {}
    },
    {
        "label": "extract_feature_value",
        "kind": 2,
        "importPath": "nlp_processor",
        "description": "nlp_processor",
        "peekOfCode": "def extract_feature_value(text, feature_word):\n    # Пример: \"с подогревом руля\" -> value = \"подогрев руля\"\n    m = re.search(rf\"{feature_word}\\s*([а-яa-z0-9\\- ]+)\", text.lower())\n    if m:\n        return m.group(1).strip()\n    return None\ndef extract_car_entities(text):\n    \"\"\"\n    Извлекает сущности автомобилей из текста.\n    Алиас для extract_entities_from_text для совместимости.",
        "detail": "nlp_processor",
        "documentation": {}
    },
    {
        "label": "extract_car_entities",
        "kind": 2,
        "importPath": "nlp_processor",
        "description": "nlp_processor",
        "peekOfCode": "def extract_car_entities(text):\n    \"\"\"\n    Извлекает сущности автомобилей из текста.\n    Алиас для extract_entities_from_text для совместимости.\n    \"\"\"\n    return extract_entities_from_text(text) \ndef call_llama3(prompt, context=None):\n    \"\"\"Вызывает Llama3 API с проверкой доступности адресов\"\"\"\n    urls = [\n        \"http://localhost:11434/api/generate\",",
        "detail": "nlp_processor",
        "documentation": {}
    },
    {
        "label": "call_llama3",
        "kind": 2,
        "importPath": "nlp_processor",
        "description": "nlp_processor",
        "peekOfCode": "def call_llama3(prompt, context=None):\n    \"\"\"Вызывает Llama3 API с проверкой доступности адресов\"\"\"\n    urls = [\n        \"http://localhost:11434/api/generate\",\n        \"http://localhost:11888/api/generate\",\n        \"http://localhost:11777/api/generate\",\n        \"http://127.0.0.1:11434/api/generate\",\n        \"http://127.0.0.1:11888/api/generate\",\n        \"http://127.0.0.1:11777/api/generate\"\n    ]",
        "detail": "nlp_processor",
        "documentation": {}
    },
    {
        "label": "extract_down_payment",
        "kind": 2,
        "importPath": "nlp_processor",
        "description": "nlp_processor",
        "peekOfCode": "def extract_down_payment(text: str) -> Optional[float]:\n    \"\"\"Извлечение первоначального взноса\"\"\"\n    patterns = [\n        r'первоначальный\\s+взнос\\s*(\\d+)',\n        r'первый\\s+взнос\\s*(\\d+)',\n        r'взнос\\s*(\\d+)',\n        r'(\\d+)\\s*первоначальный'\n    ]\n    for pattern in patterns:\n        match = re.search(pattern, text.lower())",
        "detail": "nlp_processor",
        "documentation": {}
    },
    {
        "label": "extract_term",
        "kind": 2,
        "importPath": "nlp_processor",
        "description": "nlp_processor",
        "peekOfCode": "def extract_term(text: str) -> Optional[int]:\n    \"\"\"Извлечение срока кредита\"\"\"\n    patterns = [\n        r'срок\\s*(\\d+)\\s*лет',\n        r'(\\d+)\\s*лет',\n        r'на\\s*(\\d+)\\s*лет',\n        r'кредит\\s*на\\s*(\\d+)'\n    ]\n    for pattern in patterns:\n        match = re.search(pattern, text.lower())",
        "detail": "nlp_processor",
        "documentation": {}
    },
    {
        "label": "extract_price",
        "kind": 2,
        "importPath": "nlp_processor",
        "description": "nlp_processor",
        "peekOfCode": "def extract_price(text: str) -> Optional[float]:\n    \"\"\"Извлечение цены\"\"\"\n    patterns = [\n        r'цена\\s*(\\d+)',\n        r'стоимость\\s*(\\d+)',\n        r'(\\d+)\\s*рубл',\n        r'(\\d+)\\s*млн'\n    ]\n    for pattern in patterns:\n        match = re.search(pattern, text.lower())",
        "detail": "nlp_processor",
        "documentation": {}
    },
    {
        "label": "extract_year",
        "kind": 2,
        "importPath": "nlp_processor",
        "description": "nlp_processor",
        "peekOfCode": "def extract_year(text: str) -> Optional[int]:\n    \"\"\"Извлечение года\"\"\"\n    patterns = [\n        r'(\\d{4})\\s*год',\n        r'(\\d{4})\\s*г',\n        r'(\\d{4})'\n    ]\n    for pattern in patterns:\n        match = re.search(pattern, text)\n        if match:",
        "detail": "nlp_processor",
        "documentation": {}
    },
    {
        "label": "extract_mileage",
        "kind": 2,
        "importPath": "nlp_processor",
        "description": "nlp_processor",
        "peekOfCode": "def extract_mileage(text: str) -> Optional[int]:\n    \"\"\"Извлечение пробега\"\"\"\n    patterns = [\n        r'пробег\\s*(\\d+)',\n        r'(\\d+)\\s*км',\n        r'(\\d+)\\s*тысяч\\s*км'\n    ]\n    for pattern in patterns:\n        match = re.search(pattern, text.lower())\n        if match:",
        "detail": "nlp_processor",
        "documentation": {}
    },
    {
        "label": "extract_contact",
        "kind": 2,
        "importPath": "nlp_processor",
        "description": "nlp_processor",
        "peekOfCode": "def extract_contact(text: str) -> Optional[str]:\n    \"\"\"Извлечение контактной информации\"\"\"\n    # Телефон\n    phone_pattern = r'(\\+7|8)?[\\s\\-]?\\(?(\\d{3})\\)?[\\s\\-]?(\\d{3})[\\s\\-]?(\\d{2})[\\s\\-]?(\\d{2})'\n    phone_match = re.search(phone_pattern, text)\n    if phone_match:\n        return ''.join(phone_match.groups())\n    # Email\n    email_pattern = r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b'\n    email_match = re.search(email_pattern, text)",
        "detail": "nlp_processor",
        "documentation": {}
    },
    {
        "label": "extract_date",
        "kind": 2,
        "importPath": "nlp_processor",
        "description": "nlp_processor",
        "peekOfCode": "def extract_date(text: str) -> Optional[str]:\n    \"\"\"Извлечение даты\"\"\"\n    patterns = [\n        r'(\\d{1,2})\\.(\\d{1,2})\\.(\\d{4})',\n        r'(\\d{1,2})\\.(\\d{1,2})',\n        r'(\\d{1,2})\\s+(\\w+)\\s+(\\d{4})',\n        r'завтра',\n        r'послезавтра',\n        r'сегодня'\n    ]",
        "detail": "nlp_processor",
        "documentation": {}
    },
    {
        "label": "extract_price_range",
        "kind": 2,
        "importPath": "nlp_processor",
        "description": "nlp_processor",
        "peekOfCode": "def extract_price_range(text: str) -> Tuple[Optional[float], Optional[float]]:\n    \"\"\"Извлечение диапазона цен\"\"\"\n    patterns = [\n        r'от\\s*(\\d+)\\s*до\\s*(\\d+)',\n        r'(\\d+)\\s*-\\s*(\\d+)',\n        r'цена\\s*от\\s*(\\d+)\\s*до\\s*(\\d+)'\n    ]\n    for pattern in patterns:\n        match = re.search(pattern, text.lower())\n        if match:",
        "detail": "nlp_processor",
        "documentation": {}
    },
    {
        "label": "extract_year_range",
        "kind": 2,
        "importPath": "nlp_processor",
        "description": "nlp_processor",
        "peekOfCode": "def extract_year_range(text: str) -> Tuple[Optional[int], Optional[int]]:\n    \"\"\"Извлечение диапазона лет\"\"\"\n    patterns = [\n        r'от\\s*(\\d{4})\\s*до\\s*(\\d{4})',\n        r'(\\d{4})\\s*-\\s*(\\d{4})',\n        r'год\\s*от\\s*(\\d{4})\\s*до\\s*(\\d{4})'\n    ]\n    for pattern in patterns:\n        match = re.search(pattern, text)\n        if match:",
        "detail": "nlp_processor",
        "documentation": {}
    },
    {
        "label": "extract_city",
        "kind": 2,
        "importPath": "nlp_processor",
        "description": "nlp_processor",
        "peekOfCode": "def extract_city(text: str, city_list: List[str]) -> Optional[str]:\n    \"\"\"Извлечение города\"\"\"\n    text_lower = text.lower()\n    for city in city_list:\n        if city.lower() in text_lower:\n            return city\n    return None",
        "detail": "nlp_processor",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "nlp_processor",
        "description": "nlp_processor",
        "peekOfCode": "logger = logging.getLogger(__name__)\n# Ключевые слова для новых/б/у авто\nNEW_CAR_KEYWORDS = ['новый', 'новая', 'новое', 'новые', 'свежий', 'свежая', 'свежее', 'свежие']\nUSED_CAR_KEYWORDS = ['подержанный', 'подержанная', 'подержанное', 'подержанные', 'б/у', 'б у', 'бывший в употреблении', 'использованный', 'использованная', 'использованное', 'использованные']\n# Ключевые слова для интентов\nINTENT_KEYWORDS = {\n    'search': ['найти', 'искать', 'показать', 'найди', 'ищу', 'хочу', 'нужен', 'нужна', 'нужно', 'нужны'],\n    'loan': ['кредит', 'рассчитать', 'платеж', 'взнос', 'рассрочка', 'финансирование'],\n    'test_drive': ['тест-драйв', 'тест драйв', 'прокатиться', 'попробовать', 'записаться'],\n    'trade_in': ['trade-in', 'trade in', 'обмен', 'оценить', 'сдать', 'поменять'],",
        "detail": "nlp_processor",
        "documentation": {}
    },
    {
        "label": "NEW_CAR_KEYWORDS",
        "kind": 5,
        "importPath": "nlp_processor",
        "description": "nlp_processor",
        "peekOfCode": "NEW_CAR_KEYWORDS = ['новый', 'новая', 'новое', 'новые', 'свежий', 'свежая', 'свежее', 'свежие']\nUSED_CAR_KEYWORDS = ['подержанный', 'подержанная', 'подержанное', 'подержанные', 'б/у', 'б у', 'бывший в употреблении', 'использованный', 'использованная', 'использованное', 'использованные']\n# Ключевые слова для интентов\nINTENT_KEYWORDS = {\n    'search': ['найти', 'искать', 'показать', 'найди', 'ищу', 'хочу', 'нужен', 'нужна', 'нужно', 'нужны'],\n    'loan': ['кредит', 'рассчитать', 'платеж', 'взнос', 'рассрочка', 'финансирование'],\n    'test_drive': ['тест-драйв', 'тест драйв', 'прокатиться', 'попробовать', 'записаться'],\n    'trade_in': ['trade-in', 'trade in', 'обмен', 'оценить', 'сдать', 'поменять'],\n    'dealer_center': ['дилер', 'дилерский', 'центр', 'где купить', 'адрес', 'телефон'],\n    'compare': ['сравнить', 'сравнение', 'что лучше', 'разница', 'отличия'],",
        "detail": "nlp_processor",
        "documentation": {}
    },
    {
        "label": "USED_CAR_KEYWORDS",
        "kind": 5,
        "importPath": "nlp_processor",
        "description": "nlp_processor",
        "peekOfCode": "USED_CAR_KEYWORDS = ['подержанный', 'подержанная', 'подержанное', 'подержанные', 'б/у', 'б у', 'бывший в употреблении', 'использованный', 'использованная', 'использованное', 'использованные']\n# Ключевые слова для интентов\nINTENT_KEYWORDS = {\n    'search': ['найти', 'искать', 'показать', 'найди', 'ищу', 'хочу', 'нужен', 'нужна', 'нужно', 'нужны'],\n    'loan': ['кредит', 'рассчитать', 'платеж', 'взнос', 'рассрочка', 'финансирование'],\n    'test_drive': ['тест-драйв', 'тест драйв', 'прокатиться', 'попробовать', 'записаться'],\n    'trade_in': ['trade-in', 'trade in', 'обмен', 'оценить', 'сдать', 'поменять'],\n    'dealer_center': ['дилер', 'дилерский', 'центр', 'где купить', 'адрес', 'телефон'],\n    'compare': ['сравнить', 'сравнение', 'что лучше', 'разница', 'отличия'],\n    'recommendations': ['рекомендации', 'посоветуйте', 'что посоветуете', 'совет'],",
        "detail": "nlp_processor",
        "documentation": {}
    },
    {
        "label": "INTENT_KEYWORDS",
        "kind": 5,
        "importPath": "nlp_processor",
        "description": "nlp_processor",
        "peekOfCode": "INTENT_KEYWORDS = {\n    'search': ['найти', 'искать', 'показать', 'найди', 'ищу', 'хочу', 'нужен', 'нужна', 'нужно', 'нужны'],\n    'loan': ['кредит', 'рассчитать', 'платеж', 'взнос', 'рассрочка', 'финансирование'],\n    'test_drive': ['тест-драйв', 'тест драйв', 'прокатиться', 'попробовать', 'записаться'],\n    'trade_in': ['trade-in', 'trade in', 'обмен', 'оценить', 'сдать', 'поменять'],\n    'dealer_center': ['дилер', 'дилерский', 'центр', 'где купить', 'адрес', 'телефон'],\n    'compare': ['сравнить', 'сравнение', 'что лучше', 'разница', 'отличия'],\n    'recommendations': ['рекомендации', 'посоветуйте', 'что посоветуете', 'совет'],\n    'discounts': ['скидка', 'акция', 'специальное предложение', 'выгодно', 'дешевле'],\n    'warranty': ['гарантия', 'гарантийный', 'сервис', 'обслуживание'],",
        "detail": "nlp_processor",
        "documentation": {}
    },
    {
        "label": "detect_intent",
        "kind": 2,
        "importPath": "nlp_utils",
        "description": "nlp_utils",
        "peekOfCode": "def detect_intent(text):\n    \"\"\"\n    Определяет намерение пользователя на основе текста\n    Улучшенная версия с более точным распознаванием\n    \"\"\"\n    text_lower = text.lower()\n    # Проверяем каждый тип интента с расширенными ключевыми словами\n    if any(keyword in text_lower for keyword in DEALER_CENTER_KEYWORDS):\n        return 'dealer_center'\n    if any(keyword in text_lower for keyword in SEARCH_KEYWORDS):",
        "detail": "nlp_utils",
        "documentation": {}
    },
    {
        "label": "extract_entities",
        "kind": 2,
        "importPath": "nlp_utils",
        "description": "nlp_utils",
        "peekOfCode": "def extract_entities(text):\n    \"\"\"\n    Извлекает сущности из текста\n    Улучшенная версия с более точным распознаванием\n    \"\"\"\n    entities = {}\n    text_lower = text.lower()\n    # Извлекаем бренд\n    brand = extract_brand(text_lower)\n    if brand:",
        "detail": "nlp_utils",
        "documentation": {}
    },
    {
        "label": "extract_brand",
        "kind": 2,
        "importPath": "nlp_utils",
        "description": "nlp_utils",
        "peekOfCode": "def extract_brand(text):\n    \"\"\"\n    Извлекает бренд автомобиля из текста\n    Улучшенная версия с поддержкой составных названий\n    \"\"\"\n    # Получаем все бренды из базы данных\n    all_brands = list(get_all_brand_variants())\n    # Специальная обработка для составных брендов\n    compound_brands = {\n        'tesla model': 'Tesla',",
        "detail": "nlp_utils",
        "documentation": {}
    },
    {
        "label": "extract_model",
        "kind": 2,
        "importPath": "nlp_utils",
        "description": "nlp_utils",
        "peekOfCode": "def extract_model(text, brand=None):\n    \"\"\"\n    Извлекает модель автомобиля из текста\n    Улучшенная версия с поддержкой китайских моделей\n    \"\"\"\n    # Сначала проверяем словарь синонимов китайских моделей\n    for synonym, canonical in CHINESE_MODEL_SYNONYMS.items():\n        if synonym in text:\n            return canonical\n    # Специальная обработка для популярных моделей",
        "detail": "nlp_utils",
        "documentation": {}
    },
    {
        "label": "extract_year",
        "kind": 2,
        "importPath": "nlp_utils",
        "description": "nlp_utils",
        "peekOfCode": "def extract_year(text):\n    \"\"\"\n    Извлекает год выпуска из текста\n    Улучшенная версия с поддержкой относительных дат\n    \"\"\"\n    # Ищем год в формате YYYY\n    year_match = re.search(r'(20\\d{2}|19\\d{2})', text)\n    if year_match:\n        year = int(year_match.group(1))\n        if 1900 <= year <= 2030:",
        "detail": "nlp_utils",
        "documentation": {}
    },
    {
        "label": "transliterate",
        "kind": 2,
        "importPath": "nlp_utils",
        "description": "nlp_utils",
        "peekOfCode": "def transliterate(text):\n    \"\"\"\n    Примитивная транслитерация кириллицы в латиницу и наоборот для сопоставления брендов\n    \"\"\"\n    # Создаем правильную таблицу транслитерации\n    cyrillic = 'абвгдеёжзийклмнопрстуфхцчшщьыъэюя'\n    latin = 'abvgdeejzijklmnoprstufkhtcshshch_y_eua'\n    # Проверяем, что длины равны\n    if len(cyrillic) != len(latin):\n        # Если длины не равны, обрезаем до минимальной",
        "detail": "nlp_utils",
        "documentation": {}
    },
    {
        "label": "find_similar_words",
        "kind": 2,
        "importPath": "nlp_utils",
        "description": "nlp_utils",
        "peekOfCode": "def find_similar_words(word, word_list, threshold=0.6):\n    \"\"\"\n    Находит похожие слова в списке, учитывая фонетические синонимы и транслитерацию\n    \"\"\"\n    import difflib\n    word_lower = word.lower()\n    # 1. Поиск по словарю фонетических синонимов\n    if word_lower in PHONETIC_SYNONYMS:\n        canonical = PHONETIC_SYNONYMS[word_lower]\n        for w in word_list:",
        "detail": "nlp_utils",
        "documentation": {}
    },
    {
        "label": "extract_price_range",
        "kind": 2,
        "importPath": "nlp_utils",
        "description": "nlp_utils",
        "peekOfCode": "def extract_price_range(text):\n    \"\"\"\n    Извлекает ценовой диапазон из текста\n    Улучшенная версия с поддержкой различных форматов\n    \"\"\"\n    patterns = [\n        (r\"от\\s*([\\d.,]+)\\s*тыс\\s*до\\s*([\\d.,]+)\\s*млн\", lambda x, y: (float(x.replace(',', '.'))*1000, float(y.replace(',', '.'))*1000000)),\n        (r\"от\\s*([\\d.,]+)\\s*тыс\\s*до\\s*([\\d.,]+)\\s*тыс\", lambda x, y: (float(x.replace(',', '.'))*1000, float(y.replace(',', '.'))*1000)),\n        (r\"от\\s*([\\d.,]+)\\s*млн\\s*до\\s*([\\d.,]+)\\s*млн\", lambda x, y: (float(x.replace(',', '.'))*1000000, float(y.replace(',', '.'))*1000000)),\n        (r\"от\\s*([\\d.,]+)\\s*до\\s*([\\d.,]+)\", lambda x, y: (float(x.replace(',', '.')), float(y.replace(',', '.')))),",
        "detail": "nlp_utils",
        "documentation": {}
    },
    {
        "label": "get_all_brand_variants",
        "kind": 2,
        "importPath": "nlp_utils",
        "description": "nlp_utils",
        "peekOfCode": "def get_all_brand_variants():\n    \"\"\"\n    Получает все варианты брендов\n    \"\"\"\n    try:\n        from brand_synonyms import get_all_brand_variants as get_brands\n        return get_brands()\n    except:\n        # Fallback на базовые бренды\n        return [\"Kia\", \"Hyundai\", \"Toyota\", \"BMW\", \"Audi\", \"Lada\", \"Chery\", \"Omoda\", \"Jaecoo\", \"Mercedes-Benz\", \"Tesla\"]",
        "detail": "nlp_utils",
        "documentation": {}
    },
    {
        "label": "get_first_deep",
        "kind": 2,
        "importPath": "nlp_utils",
        "description": "nlp_utils",
        "peekOfCode": "def get_first_deep(val):\n    if isinstance(val, (list, tuple)):\n        return get_first_deep(val[0]) if val else None\n    return val\ndef normalize_brand_extended(brand_input) -> Optional[str]:\n    brand_input = get_first_deep(brand_input)\n    if not brand_input:\n        return None\n    brand_input_lower = brand_input.lower().strip()\n    # ... остальной код ...",
        "detail": "nlp_utils",
        "documentation": {}
    },
    {
        "label": "normalize_brand_extended",
        "kind": 2,
        "importPath": "nlp_utils",
        "description": "nlp_utils",
        "peekOfCode": "def normalize_brand_extended(brand_input) -> Optional[str]:\n    brand_input = get_first_deep(brand_input)\n    if not brand_input:\n        return None\n    brand_input_lower = brand_input.lower().strip()\n    # ... остальной код ...\ndef normalize_text(text):\n    text = get_first_deep(text)\n    if not text:\n        return ''",
        "detail": "nlp_utils",
        "documentation": {}
    },
    {
        "label": "normalize_text",
        "kind": 2,
        "importPath": "nlp_utils",
        "description": "nlp_utils",
        "peekOfCode": "def normalize_text(text):\n    text = get_first_deep(text)\n    if not text:\n        return ''\n    words = str(text).split()\n    normalized = []\n    for word in words:\n        normalized_word = normalize_brand_extended(word.lower())\n        if normalized_word and normalized_word != word.title():\n            normalized.append(normalized_word)",
        "detail": "nlp_utils",
        "documentation": {}
    },
    {
        "label": "analyze_query",
        "kind": 2,
        "importPath": "nlp_utils",
        "description": "nlp_utils",
        "peekOfCode": "def analyze_query(user_message):\n    \"\"\"\n    Анализирует пользовательский запрос и извлекает интенты и сущности\n    Возвращает: (intent, entities, need_clarification, clarification_questions)\n    \"\"\"\n    message_lower = user_message.lower()\n    # Определяем интент\n    intent = detect_intent(user_message)\n    # Извлекаем сущности\n    entities = extract_entities(message_lower)",
        "detail": "nlp_utils",
        "documentation": {}
    },
    {
        "label": "extract_car_features",
        "kind": 2,
        "importPath": "nlp_utils",
        "description": "nlp_utils",
        "peekOfCode": "def extract_car_features(text):\n    \"\"\"\n    Извлекает дополнительные характеристики автомобиля\n    \"\"\"\n    features = {}\n    text_lower = text.lower()\n    # Цвет\n    colors = ['белый', 'черный', 'красный', 'синий', 'зеленый', 'серый', 'серебристый', 'золотой']\n    for color in colors:\n        if color in text_lower:",
        "detail": "nlp_utils",
        "documentation": {}
    },
    {
        "label": "SEARCH_KEYWORDS",
        "kind": 5,
        "importPath": "nlp_utils",
        "description": "nlp_utils",
        "peekOfCode": "SEARCH_KEYWORDS = [\n    'найти', 'поиск', 'искать', 'есть ли', 'покажи', 'найди', 'ищу', 'хочу найти',\n    'покажите', 'найдите', 'ищется', 'искал', 'искала', 'искали'\n]\nPRICE_KEYWORDS = [\n    'цена', 'стоимость', 'сколько стоит', 'почём', 'ценник', 'дорого', 'дешево',\n    'стоит', 'стоила', 'стоили', 'цену', 'стоимости', 'цене', 'ценой'\n]\nCOMPARISON_KEYWORDS = [\n    'сравни', 'сравнение', 'против', 'или', 'vs', 'versus', 'лучше', 'хуже',",
        "detail": "nlp_utils",
        "documentation": {}
    },
    {
        "label": "PRICE_KEYWORDS",
        "kind": 5,
        "importPath": "nlp_utils",
        "description": "nlp_utils",
        "peekOfCode": "PRICE_KEYWORDS = [\n    'цена', 'стоимость', 'сколько стоит', 'почём', 'ценник', 'дорого', 'дешево',\n    'стоит', 'стоила', 'стоили', 'цену', 'стоимости', 'цене', 'ценой'\n]\nCOMPARISON_KEYWORDS = [\n    'сравни', 'сравнение', 'против', 'или', 'vs', 'versus', 'лучше', 'хуже',\n    'сравнить', 'сравниваю', 'сравниваешь', 'сравнивает', 'сравнивают'\n]\nRECOMMENDATION_KEYWORDS = [\n    'рекоменд', 'посоветуй', 'что выбрать', 'какой лучше', 'подскажи',",
        "detail": "nlp_utils",
        "documentation": {}
    },
    {
        "label": "COMPARISON_KEYWORDS",
        "kind": 5,
        "importPath": "nlp_utils",
        "description": "nlp_utils",
        "peekOfCode": "COMPARISON_KEYWORDS = [\n    'сравни', 'сравнение', 'против', 'или', 'vs', 'versus', 'лучше', 'хуже',\n    'сравнить', 'сравниваю', 'сравниваешь', 'сравнивает', 'сравнивают'\n]\nRECOMMENDATION_KEYWORDS = [\n    'рекоменд', 'посоветуй', 'что выбрать', 'какой лучше', 'подскажи',\n    'совет', 'рекомендация', 'посоветуйте', 'подскажите', 'что посоветуете'\n]\nVIN_KEYWORDS = [\n    'vin', 'вин', 'номер', 'проверить', 'история', 'vin-код', 'вин-код',",
        "detail": "nlp_utils",
        "documentation": {}
    },
    {
        "label": "RECOMMENDATION_KEYWORDS",
        "kind": 5,
        "importPath": "nlp_utils",
        "description": "nlp_utils",
        "peekOfCode": "RECOMMENDATION_KEYWORDS = [\n    'рекоменд', 'посоветуй', 'что выбрать', 'какой лучше', 'подскажи',\n    'совет', 'рекомендация', 'посоветуйте', 'подскажите', 'что посоветуете'\n]\nVIN_KEYWORDS = [\n    'vin', 'вин', 'номер', 'проверить', 'история', 'vin-код', 'вин-код',\n    'vin номер', 'вин номер', 'vin код', 'вин код'\n]\nOVERVIEW_KEYWORDS = [\n    'обзор', 'информация', 'расскажи', 'что это', 'описание', 'характеристики',",
        "detail": "nlp_utils",
        "documentation": {}
    },
    {
        "label": "VIN_KEYWORDS",
        "kind": 5,
        "importPath": "nlp_utils",
        "description": "nlp_utils",
        "peekOfCode": "VIN_KEYWORDS = [\n    'vin', 'вин', 'номер', 'проверить', 'история', 'vin-код', 'вин-код',\n    'vin номер', 'вин номер', 'vin код', 'вин код'\n]\nOVERVIEW_KEYWORDS = [\n    'обзор', 'информация', 'расскажи', 'что это', 'описание', 'характеристики',\n    'расскажите', 'информацию', 'обзор', 'описание'\n]\nCONTACT_KEYWORDS = [\n    'контакт', 'телефон', 'адрес', 'связаться', 'позвонить', 'связаться',",
        "detail": "nlp_utils",
        "documentation": {}
    },
    {
        "label": "OVERVIEW_KEYWORDS",
        "kind": 5,
        "importPath": "nlp_utils",
        "description": "nlp_utils",
        "peekOfCode": "OVERVIEW_KEYWORDS = [\n    'обзор', 'информация', 'расскажи', 'что это', 'описание', 'характеристики',\n    'расскажите', 'информацию', 'обзор', 'описание'\n]\nCONTACT_KEYWORDS = [\n    'контакт', 'телефон', 'адрес', 'связаться', 'позвонить', 'связаться',\n    'контакты', 'телефонный', 'адрес', 'где находитесь'\n]\nTEST_DRIVE_KEYWORDS = [\n    'тест-драйв', 'прокат', 'попробовать', 'водить', 'тест драйв',",
        "detail": "nlp_utils",
        "documentation": {}
    },
    {
        "label": "CONTACT_KEYWORDS",
        "kind": 5,
        "importPath": "nlp_utils",
        "description": "nlp_utils",
        "peekOfCode": "CONTACT_KEYWORDS = [\n    'контакт', 'телефон', 'адрес', 'связаться', 'позвонить', 'связаться',\n    'контакты', 'телефонный', 'адрес', 'где находитесь'\n]\nTEST_DRIVE_KEYWORDS = [\n    'тест-драйв', 'прокат', 'попробовать', 'водить', 'тест драйв',\n    'прокатиться', 'попробовать машину', 'водить машину'\n]\nDEALER_CENTER_KEYWORDS = [\n    'где купить', 'в каком дц', 'дилерский центр', 'где находится', 'где приобрести',",
        "detail": "nlp_utils",
        "documentation": {}
    },
    {
        "label": "TEST_DRIVE_KEYWORDS",
        "kind": 5,
        "importPath": "nlp_utils",
        "description": "nlp_utils",
        "peekOfCode": "TEST_DRIVE_KEYWORDS = [\n    'тест-драйв', 'прокат', 'попробовать', 'водить', 'тест драйв',\n    'прокатиться', 'попробовать машину', 'водить машину'\n]\nDEALER_CENTER_KEYWORDS = [\n    'где купить', 'в каком дц', 'дилерский центр', 'где находится', 'где приобрести',\n    'где продается', 'где продаётся', 'где продают', 'где взять', 'где можно купить',\n    'какой дилер', 'какой автосалон', 'в каком автосалоне', 'где продают', 'где найти дц', 'где найти дилера'\n]\n# Расширенный словарь типов топлива",
        "detail": "nlp_utils",
        "documentation": {}
    },
    {
        "label": "DEALER_CENTER_KEYWORDS",
        "kind": 5,
        "importPath": "nlp_utils",
        "description": "nlp_utils",
        "peekOfCode": "DEALER_CENTER_KEYWORDS = [\n    'где купить', 'в каком дц', 'дилерский центр', 'где находится', 'где приобрести',\n    'где продается', 'где продаётся', 'где продают', 'где взять', 'где можно купить',\n    'какой дилер', 'какой автосалон', 'в каком автосалоне', 'где продают', 'где найти дц', 'где найти дилера'\n]\n# Расширенный словарь типов топлива\nFUEL_TYPES = {\n    'бензин': ['бензин', 'бензиновый', 'бензиновая', 'бензиновое', 'бензиновые', 'бензином'],\n    'дизель': ['дизель', 'дизельный', 'дизельная', 'дизельное', 'дизельные', 'дизелем'],\n    'гибрид': ['гибрид', 'гибридный', 'гибридная', 'гибридное', 'гибридные', 'гибридом'],",
        "detail": "nlp_utils",
        "documentation": {}
    },
    {
        "label": "FUEL_TYPES",
        "kind": 5,
        "importPath": "nlp_utils",
        "description": "nlp_utils",
        "peekOfCode": "FUEL_TYPES = {\n    'бензин': ['бензин', 'бензиновый', 'бензиновая', 'бензиновое', 'бензиновые', 'бензином'],\n    'дизель': ['дизель', 'дизельный', 'дизельная', 'дизельное', 'дизельные', 'дизелем'],\n    'гибрид': ['гибрид', 'гибридный', 'гибридная', 'гибридное', 'гибридные', 'гибридом'],\n    'электро': ['электро', 'электрический', 'электрическая', 'электрическое', 'электрические', 'электро'],\n    'газ': ['газ', 'газовый', 'газовая', 'газовое', 'газовые', 'газом', 'газобаллонное']\n}\n# Расширенный словарь типов кузова\nBODY_TYPES = {\n    'седан': ['седан', 'седан', 'седаны', 'седана', 'седаном'],",
        "detail": "nlp_utils",
        "documentation": {}
    },
    {
        "label": "BODY_TYPES",
        "kind": 5,
        "importPath": "nlp_utils",
        "description": "nlp_utils",
        "peekOfCode": "BODY_TYPES = {\n    'седан': ['седан', 'седан', 'седаны', 'седана', 'седаном'],\n    'хэтчбек': ['хэтчбек', 'хетчбек', 'хэтч', 'хетч', 'хэтчбеки', 'хетчбеки'],\n    'универсал': ['универсал', 'комби', 'универсалы', 'комби', 'универсала'],\n    'внедорожник': ['внедорожник', 'джип', 'suv', 'кроссовер', 'внедорожники', 'джипы'],\n    'купе': ['купе', 'купе', 'купе', 'купе'],\n    'кабриолет': ['кабриолет', 'кабриолет', 'кабриолеты', 'кабриолета'],\n    'лифтбек': ['лифтбек', 'лифтбеки', 'лифтбека'],\n    'пикап': ['пикап', 'пикапы', 'пикапа'],\n    'микроавтобус': ['микроавтобус', 'микроавтобусы', 'микроавтобуса', 'минивэн', 'минивэны']",
        "detail": "nlp_utils",
        "documentation": {}
    },
    {
        "label": "CAR_STATES",
        "kind": 5,
        "importPath": "nlp_utils",
        "description": "nlp_utils",
        "peekOfCode": "CAR_STATES = {\n    'new': ['новый', 'новая', 'новое', 'новые', 'без пробега', 'салон', 'с нуля', 'первый владелец'],\n    'used': ['б/у', 'бу', 'подержанный', 'подержанная', 'подержанное', 'подержанные', 'с пробегом', 'вторичка', 'вторичный']\n}\n# Фонетические синонимы для автопроизводителей (расширяем по необходимости)\nPHONETIC_SYNONYMS = {\n    'хендай': 'Hyundai',\n    'бмв': 'BMW',\n    'мерседес': 'Mercedes',\n    'мерседес-бенц': 'Mercedes-Benz',",
        "detail": "nlp_utils",
        "documentation": {}
    },
    {
        "label": "PHONETIC_SYNONYMS",
        "kind": 5,
        "importPath": "nlp_utils",
        "description": "nlp_utils",
        "peekOfCode": "PHONETIC_SYNONYMS = {\n    'хендай': 'Hyundai',\n    'бмв': 'BMW',\n    'мерседес': 'Mercedes',\n    'мерседес-бенц': 'Mercedes-Benz',\n    'ауди': 'Audi',\n    'тойота': 'Toyota',\n    'ниссан': 'Nissan',\n    'киа': 'Kia',\n    'фольксваген': 'Volkswagen',",
        "detail": "nlp_utils",
        "documentation": {}
    },
    {
        "label": "STOP_WORDS",
        "kind": 5,
        "importPath": "nlp_utils",
        "description": "nlp_utils",
        "peekOfCode": "STOP_WORDS = set([\n    'до', 'от', 'за', 'по', 'или', 'и', 'с', 'на', 'в', 'под', 'для', 'к', 'у', 'о', 'об', 'про', 'без', 'при', 'над', 'из', 'под', 'через', 'после', 'перед', 'между',\n    'внедорожник', 'внедорожники', 'кроссовер', 'кроссоверы', 'седан', 'седаны', 'универсал', 'универсалы', 'купе', 'кабриолет', 'пикап', 'минивэн', 'лифтбэк', 'хэтчбек', 'хэтчбеки',\n    'автомобиль', 'автомобили', 'машина', 'машины', 'руб', 'млн', 'тыс', 'k', 'т'\n])\ndef detect_intent(text):\n    \"\"\"\n    Определяет намерение пользователя на основе текста\n    Улучшенная версия с более точным распознаванием\n    \"\"\"",
        "detail": "nlp_utils",
        "documentation": {}
    },
    {
        "label": "NotificationSystem",
        "kind": 6,
        "importPath": "notification_system",
        "description": "notification_system",
        "peekOfCode": "class NotificationSystem:\n    \"\"\"Система уведомлений и алертов для автоассистента\"\"\"\n    def __init__(self):\n        self.user_analytics = UserAnalytics()\n        self.recommendation_engine = RecommendationEngine()\n        self.init_notification_tables()\n    def init_notification_tables(self):\n        \"\"\"Инициализирует таблицы для уведомлений\"\"\"\n        with get_db() as conn:\n            cursor = conn.cursor()",
        "detail": "notification_system",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "notification_system",
        "description": "notification_system",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass NotificationSystem:\n    \"\"\"Система уведомлений и алертов для автоассистента\"\"\"\n    def __init__(self):\n        self.user_analytics = UserAnalytics()\n        self.recommendation_engine = RecommendationEngine()\n        self.init_notification_tables()\n    def init_notification_tables(self):\n        \"\"\"Инициализирует таблицы для уведомлений\"\"\"\n        with get_db() as conn:",
        "detail": "notification_system",
        "documentation": {}
    },
    {
        "label": "check_python",
        "kind": 2,
        "importPath": "quick_check",
        "description": "quick_check",
        "peekOfCode": "def check_python():\n    \"\"\"Проверка Python\"\"\"\n    print(\"🐍 Проверка Python...\")\n    version = sys.version_info\n    print(f\"✅ Python {version.major}.{version.minor}.{version.micro}\")\n    return True\ndef check_dependencies():\n    \"\"\"Проверка зависимостей\"\"\"\n    print(\"\\n📦 Проверка зависимостей...\")\n    required = ['fastapi', 'uvicorn', 'requests', 'sqlite3']",
        "detail": "quick_check",
        "documentation": {}
    },
    {
        "label": "check_dependencies",
        "kind": 2,
        "importPath": "quick_check",
        "description": "quick_check",
        "peekOfCode": "def check_dependencies():\n    \"\"\"Проверка зависимостей\"\"\"\n    print(\"\\n📦 Проверка зависимостей...\")\n    required = ['fastapi', 'uvicorn', 'requests', 'sqlite3']\n    optional = ['psutil', 'redis', 'pytest']\n    all_good = True\n    for module in required:\n        try:\n            importlib.import_module(module)\n            print(f\"✅ {module}\")",
        "detail": "quick_check",
        "documentation": {}
    },
    {
        "label": "check_files",
        "kind": 2,
        "importPath": "quick_check",
        "description": "quick_check",
        "peekOfCode": "def check_files():\n    \"\"\"Проверка файлов\"\"\"\n    print(\"\\n📁 Проверка файлов...\")\n    files = ['app.py', 'database.py', 'dialog_manager.py', 'nlp_processor.py']\n    for file in files:\n        if os.path.exists(file):\n            size = os.path.getsize(file)\n            print(f\"✅ {file} ({size} байт)\")\n        else:\n            print(f\"❌ {file} - НЕ НАЙДЕН\")",
        "detail": "quick_check",
        "documentation": {}
    },
    {
        "label": "check_database",
        "kind": 2,
        "importPath": "quick_check",
        "description": "quick_check",
        "peekOfCode": "def check_database():\n    \"\"\"Проверка базы данных\"\"\"\n    print(\"\\n🗄️ Проверка базы данных...\")\n    db_path = \"instance/cars.db\"\n    if not os.path.exists(db_path):\n        print(f\"❌ База данных не найдена: {db_path}\")\n        return False\n    try:\n        with sqlite3.connect(db_path) as conn:\n            cursor = conn.cursor()",
        "detail": "quick_check",
        "documentation": {}
    },
    {
        "label": "check_directories",
        "kind": 2,
        "importPath": "quick_check",
        "description": "quick_check",
        "peekOfCode": "def check_directories():\n    \"\"\"Проверка директорий\"\"\"\n    print(\"\\n📂 Проверка директорий...\")\n    dirs = ['instance', 'static', 'logs', 'reports']\n    for directory in dirs:\n        if not os.path.exists(directory):\n            os.makedirs(directory)\n            print(f\"📁 Создана: {directory}\")\n        else:\n            print(f\"✅ Существует: {directory}\")",
        "detail": "quick_check",
        "documentation": {}
    },
    {
        "label": "check_psutil",
        "kind": 2,
        "importPath": "quick_check",
        "description": "quick_check",
        "peekOfCode": "def check_psutil():\n    \"\"\"Проверка psutil\"\"\"\n    print(\"\\n🔧 Проверка psutil...\")\n    try:\n        import psutil\n        print(f\"✅ psutil установлен (версия: {psutil.__version__})\")\n        return True\n    except ImportError:\n        print(\"❌ psutil не установлен\")\n        print(\"💡 Решения:\")",
        "detail": "quick_check",
        "documentation": {}
    },
    {
        "label": "check_port",
        "kind": 2,
        "importPath": "quick_check",
        "description": "quick_check",
        "peekOfCode": "def check_port():\n    \"\"\"Проверка порта\"\"\"\n    print(\"\\n🔌 Проверка порта 8001...\")\n    try:\n        import socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(2)\n        result = sock.connect_ex(('localhost', 8001))\n        sock.close()\n        if result == 0:",
        "detail": "quick_check",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "quick_check",
        "description": "quick_check",
        "peekOfCode": "def main():\n    \"\"\"Главная функция\"\"\"\n    print(\"🔍 БЫСТРАЯ ПРОВЕРКА СИСТЕМЫ\")\n    print(\"=\" * 40)\n    start_time = time.time()\n    checks = [\n        check_python,\n        check_dependencies,\n        check_files,\n        check_directories,",
        "detail": "quick_check",
        "documentation": {}
    },
    {
        "label": "RecommendationEngine",
        "kind": 6,
        "importPath": "recommendation_engine",
        "description": "recommendation_engine",
        "peekOfCode": "class RecommendationEngine:\n    \"\"\"Движок рекомендаций для автоассистента\"\"\"\n    def __init__(self):\n        self.user_history = UserHistory()\n        self.init_recommendation_tables()\n    def init_recommendation_tables(self):\n        \"\"\"Инициализирует таблицы для рекомендаций\"\"\"\n        with get_db() as conn:\n            cursor = conn.cursor()\n            # Таблица рекомендаций",
        "detail": "recommendation_engine",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "recommendation_engine",
        "description": "recommendation_engine",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass RecommendationEngine:\n    \"\"\"Движок рекомендаций для автоассистента\"\"\"\n    def __init__(self):\n        self.user_history = UserHistory()\n        self.init_recommendation_tables()\n    def init_recommendation_tables(self):\n        \"\"\"Инициализирует таблицы для рекомендаций\"\"\"\n        with get_db() as conn:\n            cursor = conn.cursor()",
        "detail": "recommendation_engine",
        "documentation": {}
    },
    {
        "label": "SimpleScheduler",
        "kind": 6,
        "importPath": "run_monitoring",
        "description": "run_monitoring",
        "peekOfCode": "class SimpleScheduler:\n    def __init__(self):\n        self.tasks = []\n    def every(self, interval):\n        return self\n    def hour(self):\n        self.tasks.append(('hourly', 3600))\n        return self\n    def day(self):\n        return self",
        "detail": "run_monitoring",
        "documentation": {}
    },
    {
        "label": "save_report",
        "kind": 2,
        "importPath": "run_monitoring",
        "description": "run_monitoring",
        "peekOfCode": "def save_report(report: dict, filename: str = \"\"):\n    \"\"\"Сохранение отчета в файл\"\"\"\n    if not filename:\n        timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        filename = f\"reports/monitoring_report_{timestamp}.json\"\n    os.makedirs(\"reports\", exist_ok=True)\n    with open(filename, 'w', encoding='utf-8') as f:\n        json.dump(report, f, ensure_ascii=False, indent=2)\n    print(f\"Отчет сохранен в {filename}\")\ndef generate_hourly_report():",
        "detail": "run_monitoring",
        "documentation": {}
    },
    {
        "label": "generate_hourly_report",
        "kind": 2,
        "importPath": "run_monitoring",
        "description": "run_monitoring",
        "peekOfCode": "def generate_hourly_report():\n    \"\"\"Генерация часового отчета\"\"\"\n    print(f\"\\n=== Генерация часового отчета {datetime.now().strftime('%Y-%m-%d %H:%M:%S')} ===\")\n    monitor = SystemMonitor()\n    report = monitor.generate_report()\n    # Выводим ключевые метрики\n    print(f\"CPU: {report['system_stats'].get('cpu_percent', 0):.1f}%\")\n    print(f\"Память: {report['system_stats'].get('memory_percent', 0):.1f}%\")\n    print(f\"Диск: {report['system_stats'].get('disk_usage', 0):.1f}%\")\n    print(f\"Запросов за 24ч: {report['api_activity']['total_requests_24h']}\")",
        "detail": "run_monitoring",
        "documentation": {}
    },
    {
        "label": "generate_daily_report",
        "kind": 2,
        "importPath": "run_monitoring",
        "description": "run_monitoring",
        "peekOfCode": "def generate_daily_report():\n    \"\"\"Генерация ежедневного отчета\"\"\"\n    print(f\"\\n=== Генерация ежедневного отчета {datetime.now().strftime('%Y-%m-%d')} ===\")\n    monitor = SystemMonitor()\n    report = monitor.generate_report()\n    # Добавляем дополнительную статистику\n    daily_stats = {\n        'date': datetime.now().strftime('%Y-%m-%d'),\n        'system_performance': {\n            'avg_cpu': report['system_stats'].get('cpu_percent', 0),",
        "detail": "run_monitoring",
        "documentation": {}
    },
    {
        "label": "monitor_system_health",
        "kind": 2,
        "importPath": "run_monitoring",
        "description": "run_monitoring",
        "peekOfCode": "def monitor_system_health():\n    \"\"\"Мониторинг здоровья системы\"\"\"\n    monitor = SystemMonitor()\n    stats = monitor.get_system_stats()\n    # Проверяем критические метрики\n    cpu_percent = stats.get('cpu_percent', 0)\n    memory_percent = stats.get('memory_percent', 0)\n    disk_usage = stats.get('disk_usage', 0)\n    warnings = []\n    if cpu_percent > 80:",
        "detail": "run_monitoring",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "run_monitoring",
        "description": "run_monitoring",
        "peekOfCode": "def main():\n    \"\"\"Основная функция\"\"\"\n    print(\"🚗 Запуск системы мониторинга автоассистента\")\n    print(\"=\" * 50)\n    # Создаем директории\n    os.makedirs(\"logs\", exist_ok=True)\n    os.makedirs(\"reports\", exist_ok=True)\n    # Простая реализация планировщика\n    last_hourly = time.time()\n    last_daily = time.time()",
        "detail": "run_monitoring",
        "documentation": {}
    },
    {
        "label": "schedule",
        "kind": 5,
        "importPath": "run_monitoring",
        "description": "run_monitoring",
        "peekOfCode": "schedule = SimpleScheduler()\ndef save_report(report: dict, filename: str = \"\"):\n    \"\"\"Сохранение отчета в файл\"\"\"\n    if not filename:\n        timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        filename = f\"reports/monitoring_report_{timestamp}.json\"\n    os.makedirs(\"reports\", exist_ok=True)\n    with open(filename, 'w', encoding='utf-8') as f:\n        json.dump(report, f, ensure_ascii=False, indent=2)\n    print(f\"Отчет сохранен в {filename}\")",
        "detail": "run_monitoring",
        "documentation": {}
    },
    {
        "label": "show_options_for_brands",
        "kind": 2,
        "importPath": "show_options_for_brands",
        "description": "show_options_for_brands",
        "peekOfCode": "def show_options_for_brands(db_path, brands):\n    conn = sqlite3.connect(db_path)\n    cursor = conn.cursor()\n    for brand in brands:\n        print(f'\\n=== Опции для автомобилей марки {brand} ===')\n        # Получаем id, модель для всех авто этой марки\n        cursor.execute(\"\"\"\n            SELECT id, mark, model FROM car WHERE LOWER(mark) = ?\n            UNION ALL\n            SELECT id, mark, model FROM used_car WHERE LOWER(mark) = ?",
        "detail": "show_options_for_brands",
        "documentation": {}
    },
    {
        "label": "check_python",
        "kind": 2,
        "importPath": "simple_start",
        "description": "simple_start",
        "peekOfCode": "def check_python():\n    \"\"\"Проверка версии Python\"\"\"\n    print(f\"🐍 Python {sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro}\")\n    return True\ndef check_database():\n    \"\"\"Проверка базы данных\"\"\"\n    print(\"🔍 Проверка базы данных...\")\n    db_path = Path(\"instance/cars.db\")\n    if not db_path.exists():\n        print(\"❌ База данных не найдена\")",
        "detail": "simple_start",
        "documentation": {}
    },
    {
        "label": "check_database",
        "kind": 2,
        "importPath": "simple_start",
        "description": "simple_start",
        "peekOfCode": "def check_database():\n    \"\"\"Проверка базы данных\"\"\"\n    print(\"🔍 Проверка базы данных...\")\n    db_path = Path(\"instance/cars.db\")\n    if not db_path.exists():\n        print(\"❌ База данных не найдена\")\n        return False\n    try:\n        with sqlite3.connect(db_path) as conn:\n            cursor = conn.cursor()",
        "detail": "simple_start",
        "documentation": {}
    },
    {
        "label": "simple_chat",
        "kind": 2,
        "importPath": "simple_start",
        "description": "simple_start",
        "peekOfCode": "def simple_chat():\n    \"\"\"Простой чат без сложных зависимостей\"\"\"\n    print(\"\\n💬 Простой чат-режим\")\n    print(\"Введите 'выход' для завершения\")\n    try:\n        with sqlite3.connect(\"instance/cars.db\") as conn:\n            cursor = conn.cursor()\n            while True:\n                user_input = input(\"\\nВы: \").strip()\n                if user_input.lower() in ['выход', 'exit', 'quit']:",
        "detail": "simple_start",
        "documentation": {}
    },
    {
        "label": "start_web_server",
        "kind": 2,
        "importPath": "simple_start",
        "description": "simple_start",
        "peekOfCode": "def start_web_server():\n    \"\"\"Запуск веб-сервера\"\"\"\n    print(\"\\n🌐 Запуск веб-сервера...\")\n    try:\n        # Проверяем наличие FastAPI\n        import fastapi\n        import uvicorn\n        print(\"✅ FastAPI найден, запускаем сервер...\")\n        print(\"📍 Веб-интерфейс: http://localhost:5000\")\n        print(\"⏹️  Для остановки нажмите Ctrl+C\")",
        "detail": "simple_start",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "simple_start",
        "description": "simple_start",
        "peekOfCode": "def main():\n    \"\"\"Основная функция\"\"\"\n    print(\"🚗 Автоассистент - Упрощенный запуск\")\n    print(\"=\" * 40)\n    # Проверки\n    if not check_python():\n        return\n    if not check_database():\n        print(\"❌ Невозможно запустить без базы данных\")\n        return",
        "detail": "simple_start",
        "documentation": {}
    },
    {
        "label": "test_single_query",
        "kind": 2,
        "importPath": "simple_test",
        "description": "simple_test",
        "peekOfCode": "def test_single_query(query):\n    \"\"\"Тестирует один запрос с детальным логированием\"\"\"\n    try:\n        print(f\"🔍 Тестируем запрос: '{query}'\")\n        from intelligent_query_processor import IntelligentQueryProcessor\n        from nlp_processor import NLPProcessor\n        # Инициализируем процессоры\n        print(\"📝 Инициализируем NLP процессор...\")\n        nlp = NLPProcessor()\n        print(\"📝 Инициализируем IQP...\")",
        "detail": "simple_test",
        "documentation": {}
    },
    {
        "label": "AutoAssistantSystem",
        "kind": 6,
        "importPath": "start_system",
        "description": "start_system",
        "peekOfCode": "class AutoAssistantSystem:\n    \"\"\"Управление системой автоассистента\"\"\"\n    def __init__(self):\n        self.processes = []\n        self.running = True\n    def print_header(self, title):\n        \"\"\"Красивый заголовок\"\"\"\n        print(f\"\\n{'='*60}\")\n        print(f\"🚗 {title}\")\n        print(f\"{'='*60}\")",
        "detail": "start_system",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "start_system",
        "description": "start_system",
        "peekOfCode": "def main():\n    \"\"\"Основная функция\"\"\"\n    system = AutoAssistantSystem()\n    try:\n        success = system.run_system()\n        if success:\n            print(\"\\n🎉 Система автоассистента успешно завершена!\")\n        else:\n            print(\"\\n❌ Ошибка запуска системы\")\n            sys.exit(1)",
        "detail": "start_system",
        "documentation": {}
    },
    {
        "label": "SystemStarter",
        "kind": 6,
        "importPath": "start_system_no_psutil",
        "description": "start_system_no_psutil",
        "peekOfCode": "class SystemStarter:\n    \"\"\"Запуск системы без psutil\"\"\"\n    def __init__(self):\n        self.processes = []\n        self.start_time = time.time()\n    def check_dependencies(self) -> bool:\n        \"\"\"Проверка зависимостей\"\"\"\n        logger.info(\"Проверка зависимостей...\")\n        required_modules = [\n            'fastapi',",
        "detail": "start_system_no_psutil",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "start_system_no_psutil",
        "description": "start_system_no_psutil",
        "peekOfCode": "def main():\n    \"\"\"Главная функция\"\"\"\n    starter = SystemStarter()\n    # Обработка сигналов\n    def signal_handler(signum, frame):\n        logger.info(f\"Получен сигнал {signum}\")\n        starter.stop_all_processes()\n        sys.exit(0)\n    signal.signal(signal.SIGINT, signal_handler)\n    signal.signal(signal.SIGTERM, signal_handler)",
        "detail": "start_system_no_psutil",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "start_system_no_psutil",
        "description": "start_system_no_psutil",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass SystemStarter:\n    \"\"\"Запуск системы без psutil\"\"\"\n    def __init__(self):\n        self.processes = []\n        self.start_time = time.time()\n    def check_dependencies(self) -> bool:\n        \"\"\"Проверка зависимостей\"\"\"\n        logger.info(\"Проверка зависимостей...\")\n        required_modules = [",
        "detail": "start_system_no_psutil",
        "documentation": {}
    },
    {
        "label": "check_python_version",
        "kind": 2,
        "importPath": "start_windows",
        "description": "start_windows",
        "peekOfCode": "def check_python_version():\n    \"\"\"Проверка версии Python\"\"\"\n    print(\"🔍 Проверка версии Python...\")\n    version = sys.version_info\n    if version.major < 3 or (version.major == 3 and version.minor < 8):\n        print(\"❌ Требуется Python 3.8 или выше\")\n        print(f\"   Текущая версия: {version.major}.{version.minor}.{version.micro}\")\n        return False\n    print(f\"✅ Python {version.major}.{version.minor}.{version.micro} - OK\")\n    return True",
        "detail": "start_windows",
        "documentation": {}
    },
    {
        "label": "install_package",
        "kind": 2,
        "importPath": "start_windows",
        "description": "start_windows",
        "peekOfCode": "def install_package(package):\n    \"\"\"Установка пакета через pip\"\"\"\n    try:\n        print(f\"📦 Установка {package}...\")\n        subprocess.check_call([sys.executable, \"-m\", \"pip\", \"install\", package], \n                            stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\n        print(f\"✅ {package} установлен\")\n        return True\n    except subprocess.CalledProcessError:\n        print(f\"❌ Ошибка установки {package}\")",
        "detail": "start_windows",
        "documentation": {}
    },
    {
        "label": "check_and_install_dependencies",
        "kind": 2,
        "importPath": "start_windows",
        "description": "start_windows",
        "peekOfCode": "def check_and_install_dependencies():\n    \"\"\"Проверка и установка зависимостей\"\"\"\n    print(\"\\n🔍 Проверка зависимостей...\")\n    required_packages = [\n        'fastapi',\n        'uvicorn[standard]',\n        'redis',\n        'requests',\n        'pydantic',\n        'typing-extensions',",
        "detail": "start_windows",
        "documentation": {}
    },
    {
        "label": "check_database",
        "kind": 2,
        "importPath": "start_windows",
        "description": "start_windows",
        "peekOfCode": "def check_database():\n    \"\"\"Проверка базы данных\"\"\"\n    print(\"\\n🔍 Проверка базы данных...\")\n    db_path = Path(\"instance/cars.db\")\n    if db_path.exists():\n        size_mb = db_path.stat().st_size / (1024 * 1024)\n        print(f\"✅ База данных найдена ({size_mb:.1f} MB)\")\n        return True\n    else:\n        print(\"❌ База данных не найдена\")",
        "detail": "start_windows",
        "documentation": {}
    },
    {
        "label": "check_static_files",
        "kind": 2,
        "importPath": "start_windows",
        "description": "start_windows",
        "peekOfCode": "def check_static_files():\n    \"\"\"Проверка статических файлов\"\"\"\n    print(\"\\n🔍 Проверка веб-интерфейса...\")\n    static_files = [\n        \"static/index.html\",\n        \"static/dashboard.html\",\n        \"static/dashboard.js\",\n        \"static/dashboard.css\"\n    ]\n    missing_files = []",
        "detail": "start_windows",
        "documentation": {}
    },
    {
        "label": "start_server",
        "kind": 2,
        "importPath": "start_windows",
        "description": "start_windows",
        "peekOfCode": "def start_server():\n    \"\"\"Запуск сервера\"\"\"\n    print(\"\\n🚀 Запуск автоассистента...\")\n    print(\"📍 Веб-интерфейс: http://localhost:5000\")\n    print(\"📍 API документация: http://localhost:5000/docs\")\n    print(\"📍 Админ-панель: http://localhost:5000/static/dashboard.html\")\n    print(\"\\n⏹️  Для остановки нажмите Ctrl+C\")\n    try:\n        import uvicorn\n        uvicorn.run(",
        "detail": "start_windows",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "start_windows",
        "description": "start_windows",
        "peekOfCode": "def main():\n    \"\"\"Основная функция\"\"\"\n    print(\"🚗 Автоассистент - Запуск системы\")\n    print(\"=\" * 50)\n    # Проверка версии Python\n    if not check_python_version():\n        return\n    # Проверка и установка зависимостей\n    if not check_and_install_dependencies():\n        print(\"❌ Не удалось установить зависимости\")",
        "detail": "start_windows",
        "documentation": {}
    },
    {
        "label": "SystemDiagnostic",
        "kind": 6,
        "importPath": "system_diagnostic",
        "description": "system_diagnostic",
        "peekOfCode": "class SystemDiagnostic:\n    \"\"\"Диагностика системы\"\"\"\n    def __init__(self):\n        self.issues = []\n        self.fixes_applied = []\n    def check_python_version(self) -> bool:\n        \"\"\"Проверка версии Python\"\"\"\n        print(\"🐍 Проверка версии Python...\")\n        version = sys.version_info\n        if version.major >= 3 and version.minor >= 8:",
        "detail": "system_diagnostic",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "system_diagnostic",
        "description": "system_diagnostic",
        "peekOfCode": "def main():\n    \"\"\"Главная функция\"\"\"\n    diagnostic = SystemDiagnostic()\n    success = diagnostic.run_full_diagnostic()\n    if success:\n        print(\"\\n🚀 Система готова к работе!\")\n        return 0\n    else:\n        print(\"\\n⚠️ Обнаружены проблемы. Исправьте их перед запуском.\")\n        return 1",
        "detail": "system_diagnostic",
        "documentation": {}
    },
    {
        "label": "test_passengers_api",
        "kind": 2,
        "importPath": "test_api_passengers",
        "description": "test_api_passengers",
        "peekOfCode": "def test_passengers_api():\n    \"\"\"Тестируем API с запросом '7 пассажиров'\"\"\"\n    base_url = \"http://localhost:8000\"\n    # Сначала получаем CSRF токен\n    try:\n        csrf_response = requests.get(f\"{base_url}/api/csrf-token\", timeout=10)\n        if csrf_response.status_code == 200:\n            csrf_token = csrf_response.json().get('csrf_token')\n            print(f\"✅ CSRF токен получен: {csrf_token[:20]}...\")\n        else:",
        "detail": "test_api_passengers",
        "documentation": {}
    },
    {
        "label": "test_tiggo_query",
        "kind": 2,
        "importPath": "test_api_passengers",
        "description": "test_api_passengers",
        "peekOfCode": "def test_tiggo_query():\n    \"\"\"Тестируем API с запросом 'тиго макс 7 про'\"\"\"\n    base_url = \"http://localhost:8000\"\n    # Сначала получаем CSRF токен\n    try:\n        csrf_response = requests.get(f\"{base_url}/api/csrf-token\", timeout=10)\n        if csrf_response.status_code == 200:\n            csrf_token = csrf_response.json().get('csrf_token')\n            print(f\"✅ CSRF токен получен: {csrf_token[:20]}...\")\n        else:",
        "detail": "test_api_passengers",
        "documentation": {}
    },
    {
        "label": "test_availability_queries",
        "kind": 2,
        "importPath": "test_availability",
        "description": "test_availability",
        "peekOfCode": "def test_availability_queries():\n    \"\"\"Тестирует различные запросы о наличии автомобилей\"\"\"\n    base_url = \"http://localhost:5000\"\n    # Список тестовых запросов\n    test_queries = [\n        \"какие автомобили есть в наличии?\",\n        \"есть ли в наличии BMW?\",\n        \"покажи все автомобили\",\n        \"выведи все авто\",\n        \"есть ли Mercedes в Москве?\",",
        "detail": "test_availability",
        "documentation": {}
    },
    {
        "label": "test_specific_scenarios",
        "kind": 2,
        "importPath": "test_availability",
        "description": "test_availability",
        "peekOfCode": "def test_specific_scenarios():\n    \"\"\"Тестирует конкретные сценарии\"\"\"\n    base_url = \"http://localhost:5000\"\n    print(\"🎯 Тестирование конкретных сценариев\\n\")\n    # Сценарий 1: Вопрос о наличии BMW\n    print(\"🎯 Сценарий 1: Вопрос о наличии BMW\")\n    print(\"-\" * 40)\n    try:\n        response = requests.post(\n            f\"{base_url}/api/chat\",",
        "detail": "test_availability",
        "documentation": {}
    },
    {
        "label": "test_bmw_query_direct",
        "kind": 2,
        "importPath": "test_bmw_direct",
        "description": "test_bmw_direct",
        "peekOfCode": "def test_bmw_query_direct():\n    \"\"\"Тест запроса 'bmw' напрямую через процессор\"\"\"\n    # Инициализация\n    nlp = NLPProcessor()\n    iqp = IntelligentQueryProcessor(nlp)\n    print(\"=== Тест запроса 'bmw' ===\")\n    # Тестируем запрос \"bmw\"\n    result = iqp.process_query(\"bmw\", \"test_user\")\n    print(f\"Тип ответа: {result.get('type')}\")\n    print(f\"Количество автомобилей: {result.get('count', 0)}\")",
        "detail": "test_bmw_direct",
        "documentation": {}
    },
    {
        "label": "test_bmw_x5_query_direct",
        "kind": 2,
        "importPath": "test_bmw_direct",
        "description": "test_bmw_direct",
        "peekOfCode": "def test_bmw_x5_query_direct():\n    \"\"\"Тест запроса 'bmw x5' напрямую через процессор\"\"\"\n    # Инициализация\n    nlp = NLPProcessor()\n    iqp = IntelligentQueryProcessor(nlp)\n    print(\"=== Тест запроса 'bmw x5' ===\")\n    # Тестируем запрос \"bmw x5\"\n    result = iqp.process_query(\"bmw x5\", \"test_user\")\n    print(f\"Тип ответа: {result.get('type')}\")\n    print(f\"Количество автомобилей: {result.get('count', 0)}\")",
        "detail": "test_bmw_direct",
        "documentation": {}
    },
    {
        "label": "test_mercedes_query_direct",
        "kind": 2,
        "importPath": "test_bmw_direct",
        "description": "test_bmw_direct",
        "peekOfCode": "def test_mercedes_query_direct():\n    \"\"\"Тест запроса 'mercedes' напрямую через процессор\"\"\"\n    # Инициализация\n    nlp = NLPProcessor()\n    iqp = IntelligentQueryProcessor(nlp)\n    print(\"=== Тест запроса 'mercedes' ===\")\n    # Тестируем запрос \"mercedes\"\n    result = iqp.process_query(\"mercedes\", \"test_user\")\n    print(f\"Тип ответа: {result.get('type')}\")\n    print(f\"Количество автомобилей: {result.get('count', 0)}\")",
        "detail": "test_bmw_direct",
        "documentation": {}
    },
    {
        "label": "test_bmw_query",
        "kind": 2,
        "importPath": "test_bmw_query",
        "description": "test_bmw_query",
        "peekOfCode": "def test_bmw_query():\n    \"\"\"Тест запроса 'bmw' к серверу\"\"\"\n    url = \"http://localhost:8000/api/chat\"\n    data = {\n        \"message\": \"bmw\",\n        \"user_id\": \"test_user\"\n    }\n    try:\n        print(\"Отправляем запрос 'bmw'...\")\n        response = requests.post(url, json=data)",
        "detail": "test_bmw_query",
        "documentation": {}
    },
    {
        "label": "test_brand_model_llama",
        "kind": 2,
        "importPath": "test_brand_model_llama",
        "description": "test_brand_model_llama",
        "peekOfCode": "def test_brand_model_llama():\n    \"\"\"Тест отправки запросов с маркой и моделью на Llama\"\"\"\n    # Инициализация\n    nlp = NLPProcessor()\n    iqp = IntelligentQueryProcessor(nlp)\n    # Тест 1: Запрос с маркой и моделью (должен идти на Llama)\n    print(\"=== Тест 1: Запрос с маркой и моделью ===\")\n    result1 = iqp.process_query(\"bmw x5\", \"test_user\")\n    print(f\"Тип ответа: {result1.get('type')}\")\n    print(f\"Сообщение: {result1.get('message', '')[:100]}...\")",
        "detail": "test_brand_model_llama",
        "documentation": {}
    },
    {
        "label": "test_color_search",
        "kind": 2,
        "importPath": "test_colors",
        "description": "test_colors",
        "peekOfCode": "def test_color_search():\n    url = \"http://localhost:5000/api/chat\"\n    # Тест поиска по нескольким цветам\n    test_message = \"покажи красные и синие машины\"\n    payload = {\n        \"message\": test_message,\n        \"user_id\": \"test_user\"\n    }\n    headers = {\n        \"Content-Type\": \"application/json\"",
        "detail": "test_colors",
        "documentation": {}
    },
    {
        "label": "test_color_filtering",
        "kind": 2,
        "importPath": "test_color_filter",
        "description": "test_color_filter",
        "peekOfCode": "def test_color_filtering():\n    print(\"🔍 Тестируем фильтрацию по цвету...\")\n    # Инициализируем процессоры\n    nlp = NLPProcessor()\n    iqp = IntelligentQueryProcessor(nlp)\n    # Тестируем запрос синих автомобилей\n    query = \"Покажи синий автомобиль\"\n    print(f\"📝 Запрос: {query}\")\n    try:\n        result = iqp.process_query(query)",
        "detail": "test_color_filter",
        "documentation": {}
    },
    {
        "label": "test_debug_query",
        "kind": 2,
        "importPath": "test_debug_query",
        "description": "test_debug_query",
        "peekOfCode": "def test_debug_query():\n    \"\"\"Отладочный тест обработки запроса\"\"\"\n    print(\"🔍 Отладочный тест обработки запроса...\")\n    # Создаем экземпляры процессоров\n    nlp = NLPProcessor()\n    iqp = IntelligentQueryProcessor(nlp)\n    # Тестируем запрос\n    query = \"найди машины белого цвета марки мерседес\"\n    user_id = \"test_user\"\n    print(f\"📝 Запрос: {query}\")",
        "detail": "test_debug_query",
        "documentation": {}
    },
    {
        "label": "test_deepseek_api",
        "kind": 2,
        "importPath": "test_deepseek_fix",
        "description": "test_deepseek_fix",
        "peekOfCode": "def test_deepseek_api():\n    \"\"\"Тестирует DeepSeek API с исправленным форматом запроса\"\"\"\n    print(\"=== ТЕСТ DEEPSEEK API ===\")\n    # Проверяем доступность API\n    try:\n        print(\"1. Проверяем доступность API...\")\n        response = requests.get(\"http://localhost:11888/api/tags\", timeout=5)\n        print(f\"   Статус: {response.status_code}\")\n        if response.status_code == 200:\n            print(\"   ✅ API доступен\")",
        "detail": "test_deepseek_fix",
        "documentation": {}
    },
    {
        "label": "test_fast_car_query",
        "kind": 2,
        "importPath": "test_fast_car_fix",
        "description": "test_fast_car_fix",
        "peekOfCode": "def test_fast_car_query():\n    \"\"\"Тестирует обработку запроса 'покажи быстрый автомобиль'\"\"\"\n    print(\"=== ТЕСТ ОБРАБОТКИ ЗАПРОСА 'ПОКАЖИ БЫСТРЫЙ АВТОМОБИЛЬ' ===\\n\")\n    # Инициализируем процессоры\n    nlp_processor = NLPProcessor()\n    iqp = IntelligentQueryProcessor(nlp_processor)\n    # Тестовый запрос\n    query = \"покажи быстрый автомобиль\"\n    user_id = \"test_user\"\n    print(f\"🔍 Тестовый запрос: '{query}'\")",
        "detail": "test_fast_car_fix",
        "documentation": {}
    },
    {
        "label": "test_regular_model_query",
        "kind": 2,
        "importPath": "test_fast_car_fix",
        "description": "test_fast_car_fix",
        "peekOfCode": "def test_regular_model_query():\n    \"\"\"Тестирует обработку обычного запроса с моделью для сравнения\"\"\"\n    print(\"\\n=== ТЕСТ ОБЫЧНОГО ЗАПРОСА С МОДЕЛЬЮ ===\\n\")\n    # Инициализируем процессоры\n    nlp_processor = NLPProcessor()\n    iqp = IntelligentQueryProcessor(nlp_processor)\n    # Тестовый запрос с реальной моделью\n    query = \"bmw x5\"\n    user_id = \"test_user\"\n    print(f\"🔍 Тестовый запрос: '{query}'\")",
        "detail": "test_fast_car_fix",
        "documentation": {}
    },
    {
        "label": "nlp",
        "kind": 5,
        "importPath": "test_fast_fix",
        "description": "test_fast_fix",
        "peekOfCode": "nlp = NLPProcessor()\niqp = IntelligentQueryProcessor(nlp)\n# Тестируем запрос\nresult = iqp.process_query('покажи быстрый автомобиль', 'test_user')\nprint('Тип ответа:', result.get('type'))\nprint('Количество машин:', len(result.get('cars', [])))\nif result.get('type') == 'car_list':\n    print('✅ УСПЕХ: Запрос обработан как поиск быстрых автомобилей!')\nelif result.get('type') == 'no_results':\n    print('❌ ПРОБЛЕМА: Система все еще воспринимает \"быстрый\" как модель!')",
        "detail": "test_fast_fix",
        "documentation": {}
    },
    {
        "label": "iqp",
        "kind": 5,
        "importPath": "test_fast_fix",
        "description": "test_fast_fix",
        "peekOfCode": "iqp = IntelligentQueryProcessor(nlp)\n# Тестируем запрос\nresult = iqp.process_query('покажи быстрый автомобиль', 'test_user')\nprint('Тип ответа:', result.get('type'))\nprint('Количество машин:', len(result.get('cars', [])))\nif result.get('type') == 'car_list':\n    print('✅ УСПЕХ: Запрос обработан как поиск быстрых автомобилей!')\nelif result.get('type') == 'no_results':\n    print('❌ ПРОБЛЕМА: Система все еще воспринимает \"быстрый\" как модель!')\nelse:",
        "detail": "test_fast_fix",
        "documentation": {}
    },
    {
        "label": "result",
        "kind": 5,
        "importPath": "test_fast_fix",
        "description": "test_fast_fix",
        "peekOfCode": "result = iqp.process_query('покажи быстрый автомобиль', 'test_user')\nprint('Тип ответа:', result.get('type'))\nprint('Количество машин:', len(result.get('cars', [])))\nif result.get('type') == 'car_list':\n    print('✅ УСПЕХ: Запрос обработан как поиск быстрых автомобилей!')\nelif result.get('type') == 'no_results':\n    print('❌ ПРОБЛЕМА: Система все еще воспринимает \"быстрый\" как модель!')\nelse:\n    print(f'📋 Результат: {result.get(\"type\")}')",
        "detail": "test_fast_fix",
        "documentation": {}
    },
    {
        "label": "TestTiggoModelQuery",
        "kind": 6,
        "importPath": "test_intelligent_query_processor",
        "description": "test_intelligent_query_processor",
        "peekOfCode": "class TestTiggoModelQuery(unittest.TestCase):\n    def setUp(self):\n        nlp = NLPProcessor()\n        self.iqp = IntelligentQueryProcessor(nlp)\n    def test_tiggo_7_pro_max(self):\n        query = \"тиго макс 7 про\"\n        user_id = \"test_user\"\n        # Вызов основной функции обработки запроса\n        result = self.iqp.process_query(query, user_id=user_id)\n        # Проверяем, что результат содержит нужные поля",
        "detail": "test_intelligent_query_processor",
        "documentation": {}
    },
    {
        "label": "test_chat_endpoint",
        "kind": 2,
        "importPath": "test_llm_integration",
        "description": "test_llm_integration",
        "peekOfCode": "def test_chat_endpoint(message, user_id=\"test_user\"):\n    \"\"\"Тестирует эндпоинт чата\"\"\"\n    url = f\"{BASE_URL}/api/chat\"\n    data = {\n        \"message\": message,\n        \"user_id\": user_id\n    }\n    try:\n        response = requests.post(url, json=data, timeout=30)\n        if response.status_code == 200:",
        "detail": "test_llm_integration",
        "documentation": {}
    },
    {
        "label": "test_simple_queries",
        "kind": 2,
        "importPath": "test_llm_integration",
        "description": "test_llm_integration",
        "peekOfCode": "def test_simple_queries():\n    \"\"\"Тестирует простые запросы (не должны идти к LLM)\"\"\"\n    print(\"🔍 Тестирование простых запросов:\")\n    simple_queries = [\n        \"Найти BMW X5\",\n        \"Показать автомобили до 3 млн\",\n        \"Электромобили в Москве\",\n        \"Какие автомобили есть в наличии?\",\n        \"Статистика опций\"\n    ]",
        "detail": "test_llm_integration",
        "documentation": {}
    },
    {
        "label": "test_complex_queries",
        "kind": 2,
        "importPath": "test_llm_integration",
        "description": "test_llm_integration",
        "peekOfCode": "def test_complex_queries():\n    \"\"\"Тестирует сложные запросы (должны идти к LLM)\"\"\"\n    print(\"\\n🤖 Тестирование сложных запросов (LLM):\")\n    complex_queries = [\n        \"Почему BMW X5 лучше Mercedes GLE?\",\n        \"Как выбрать семейный автомобиль?\",\n        \"Объясни разницу между бензиновым и дизельным двигателем\",\n        \"Что если я хочу экономичный автомобиль для города?\",\n        \"Посоветуй, какой автомобиль лучше для поездок на дачу\",\n        \"Сравни преимущества и недостатки электромобилей\"",
        "detail": "test_llm_integration",
        "documentation": {}
    },
    {
        "label": "test_chat_history",
        "kind": 2,
        "importPath": "test_llm_integration",
        "description": "test_llm_integration",
        "peekOfCode": "def test_chat_history():\n    \"\"\"Тестирует работу с историей чата\"\"\"\n    print(\"\\n💬 Тестирование истории чата:\")\n    user_id = \"history_test_user\"\n    # Первый запрос\n    print(f\"\\n📝 Запрос 1: 'Найти BMW X5'\")\n    response1 = test_chat_endpoint(\"Найти BMW X5\", user_id)\n    time.sleep(1)\n    # Второй запрос (должен учитывать контекст)\n    print(f\"\\n📝 Запрос 2: 'А что насчет Mercedes?'\")",
        "detail": "test_llm_integration",
        "documentation": {}
    },
    {
        "label": "test_fallback_scenarios",
        "kind": 2,
        "importPath": "test_llm_integration",
        "description": "test_llm_integration",
        "peekOfCode": "def test_fallback_scenarios():\n    \"\"\"Тестирует различные сценарии fallback\"\"\"\n    print(\"\\n⚠️ Тестирование fallback сценариев:\")\n    # Тестируем запросы, которые должны дать fallback\n    fallback_queries = [\n        \"Почему небо голубое?\",  # Вопрос не про автомобили\n        \"Как приготовить борщ?\",  # Совсем не про автомобили\n        \"Что такое квантовая физика?\"  # Сложный вопрос не по теме\n    ]\n    for query in fallback_queries:",
        "detail": "test_llm_integration",
        "documentation": {}
    },
    {
        "label": "test_availability_queries",
        "kind": 2,
        "importPath": "test_llm_integration",
        "description": "test_llm_integration",
        "peekOfCode": "def test_availability_queries():\n    \"\"\"Тестирует запросы о наличии\"\"\"\n    print(\"\\n📊 Тестирование запросов о наличии:\")\n    availability_queries = [\n        \"Какие автомобили есть в наличии?\",\n        \"Покажи все автомобили\",\n        \"Есть ли BMW в наличии?\",\n        \"Какие автомобили доступны в Москве?\"\n    ]\n    for query in availability_queries:",
        "detail": "test_llm_integration",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "test_llm_integration",
        "description": "test_llm_integration",
        "peekOfCode": "def main():\n    \"\"\"Основная функция тестирования\"\"\"\n    print(\"🚗 Тестирование интеграции с LLM моделью\")\n    print(\"=\" * 50)\n    try:\n        # Проверяем доступность сервера\n        health_response = requests.get(f\"{BASE_URL}/api/health\", timeout=5)\n        if health_response.status_code != 200:\n            print(\"❌ Сервер недоступен\")\n            return",
        "detail": "test_llm_integration",
        "documentation": {}
    },
    {
        "label": "BASE_URL",
        "kind": 5,
        "importPath": "test_llm_integration",
        "description": "test_llm_integration",
        "peekOfCode": "BASE_URL = \"http://localhost:8000\"\ndef test_chat_endpoint(message, user_id=\"test_user\"):\n    \"\"\"Тестирует эндпоинт чата\"\"\"\n    url = f\"{BASE_URL}/api/chat\"\n    data = {\n        \"message\": message,\n        \"user_id\": user_id\n    }\n    try:\n        response = requests.post(url, json=data, timeout=30)",
        "detail": "test_llm_integration",
        "documentation": {}
    },
    {
        "label": "test_mercedes_debug",
        "kind": 2,
        "importPath": "test_mercedes_debug",
        "description": "test_mercedes_debug",
        "peekOfCode": "def test_mercedes_debug():\n    \"\"\"Отладка проблемы с Mercedes\"\"\"\n    print(\"=== Отладка Mercedes ===\")\n    # 1. Проверяем NLP обработку\n    nlp = NLPProcessor()\n    result = nlp.process_query(\"mercedes\", \"test_user\")\n    print(f\"NLP результат: {result}\")\n    # 2. Проверяем, есть ли Mercedes в базе данных\n    all_cars = search_all_cars()\n    mercedes_cars = [car for car in all_cars if 'mercedes' in car.get('mark', '').lower()]",
        "detail": "test_mercedes_debug",
        "documentation": {}
    },
    {
        "label": "test_mercedes_white_direct",
        "kind": 2,
        "importPath": "test_mercedes_direct",
        "description": "test_mercedes_direct",
        "peekOfCode": "def test_mercedes_white_direct():\n    \"\"\"Прямой тест функции handle_recommendation\"\"\"\n    print(\"🔍 Тестируем поиск Mercedes белого цвета напрямую...\")\n    # Создаем экземпляры процессоров\n    nlp = NLPProcessor()\n    iqp = IntelligentQueryProcessor(nlp)\n    # Тестируем запрос\n    query = \"найди машины белого цвета марки мерседес\"\n    user_id = \"test_user\"\n    try:",
        "detail": "test_mercedes_direct",
        "documentation": {}
    },
    {
        "label": "test_mercedes_white",
        "kind": 2,
        "importPath": "test_mercedes_white",
        "description": "test_mercedes_white",
        "peekOfCode": "def test_mercedes_white():\n    \"\"\"Тестируем поиск Mercedes белого цвета\"\"\"\n    url = \"http://localhost:5000/api/chat\"\n    # Тестируем запрос с Mercedes и белым цветом\n    message = \"найди машины белого цвета марки мерседес\"\n    data = {\n        \"message\": message,\n        \"user_id\": \"test_user\"\n    }\n    try:",
        "detail": "test_mercedes_white",
        "documentation": {}
    },
    {
        "label": "test_mercedes_white_with_csrf",
        "kind": 2,
        "importPath": "test_mercedes_white_csrf",
        "description": "test_mercedes_white_csrf",
        "peekOfCode": "def test_mercedes_white_with_csrf():\n    \"\"\"Тестируем поиск Mercedes белого цвета с CSRF токеном\"\"\"\n    base_url = \"http://localhost:5000\"\n    # Шаг 1: Получаем CSRF токен\n    print(\"🔑 Получаем CSRF токен...\")\n    try:\n        csrf_response = requests.get(f\"{base_url}/api/csrf-token\")\n        if csrf_response.status_code == 200:\n            csrf_data = csrf_response.json()\n            csrf_token = csrf_data.get('token', '')",
        "detail": "test_mercedes_white_csrf",
        "documentation": {}
    },
    {
        "label": "TestModelInfo",
        "kind": 6,
        "importPath": "test_model_info",
        "description": "test_model_info",
        "peekOfCode": "class TestModelInfo(unittest.TestCase):\n    def setUp(self):\n        nlp = NLPProcessor()\n        self.iqp = IntelligentQueryProcessor(nlp)\n    def test_get_model_info(self):\n        \"\"\"Тест получения информации о модели\"\"\"\n        # Тестовые данные автомобилей\n        test_cars = [\n            {\n                'mark': 'Chery',",
        "detail": "test_model_info",
        "documentation": {}
    },
    {
        "label": "test_color_scenarios",
        "kind": 2,
        "importPath": "test_multiple_colors",
        "description": "test_multiple_colors",
        "peekOfCode": "def test_color_scenarios():\n    \"\"\"Тестируем различные сценарии поиска по цветам\"\"\"\n    print(\"🎨 Тестируем различные сценарии поиска по цветам...\")\n    # Создаем экземпляры процессоров\n    nlp = NLPProcessor()\n    iqp = IntelligentQueryProcessor(nlp)\n    # Список тестовых запросов\n    test_queries = [\n        \"найди машины белого цвета марки мерседес\",\n        \"найди машины белого, синего и красного цвета\",",
        "detail": "test_multiple_colors",
        "documentation": {}
    },
    {
        "label": "test_ollama",
        "kind": 2,
        "importPath": "test_ollama",
        "description": "test_ollama",
        "peekOfCode": "def test_ollama():\n    url = \"http://localhost:11434/api/generate\"\n    payload = {\n        \"model\": \"llama3:8b\",\n        \"prompt\": \"ping\",\n        \"stream\": False\n    }\n    try:\n        print(f\"Отправляем запрос к {url}\")\n        response = requests.post(url, json=payload, timeout=60)",
        "detail": "test_ollama",
        "documentation": {}
    },
    {
        "label": "test_price_extraction",
        "kind": 2,
        "importPath": "test_price_extraction",
        "description": "test_price_extraction",
        "peekOfCode": "def test_price_extraction():\n    parser = CarParser()\n    test_cases = [\n        '6 690 000 р.',\n        '6 830 000 р.',\n        '7 541 000 р.',\n        '6,690,000 руб',\n        '6830000'\n    ]\n    print(\"Testing price extraction:\")",
        "detail": "test_price_extraction",
        "documentation": {}
    },
    {
        "label": "test_query",
        "kind": 2,
        "importPath": "test_queries_no_api",
        "description": "test_queries_no_api",
        "peekOfCode": "def test_query(query):\n    nlp = NLPProcessor()\n    processor = IntelligentQueryProcessor(nlp)\n    user_id = \"test_user\"\n    print(f\"\\n=== ТЕСТ: {query} ===\")\n    result = processor.process_query(query, user_id)\n    print(f\"Тип ответа: {result.get('type', 'unknown')}\")\n    print(f\"Найдено машин: {len(result.get('cars', [])) if 'cars' in result else 0}\")\n    print(f\"Сообщение: {result.get('message', '')[:500]}...\")\n    if 'cars' in result and result['cars']:",
        "detail": "test_queries_no_api",
        "documentation": {}
    },
    {
        "label": "test_query",
        "kind": 2,
        "importPath": "test_query",
        "description": "test_query",
        "peekOfCode": "def test_query():\n    url = \"http://localhost:8000/api/chat\"\n    # Сначала получаем CSRF токен\n    session = requests.Session()\n    try:\n        # Получаем главную страницу для получения CSRF токена\n        main_page = session.get(\"http://localhost:5000/\")\n        if main_page.status_code == 200:\n            print(\"Главная страница загружена успешно\")\n        else:",
        "detail": "test_query",
        "documentation": {}
    },
    {
        "label": "test_batch_queries",
        "kind": 2,
        "importPath": "test_query",
        "description": "test_query",
        "peekOfCode": "def test_batch_queries():\n    url = \"http://localhost:5000/api/chat\"\n    session = requests.Session()\n    try:\n        main_page = session.get(\"http://localhost:5000/\")\n        if main_page.status_code != 200:\n            print(f\"Ошибка загрузки главной страницы: {main_page.status_code}\")\n            return\n    except Exception as e:\n        print(f\"Ошибка при загрузке главной страницы: {e}\")",
        "detail": "test_query",
        "documentation": {}
    },
    {
        "label": "TEST_QUERIES",
        "kind": 5,
        "importPath": "test_query",
        "description": "test_query",
        "peekOfCode": "TEST_QUERIES = [\n    \"найди машину красного и синего цвета\",\n    \"найди мерседес белого цвета\",\n    \"найди бежевую машину\",\n    \"найди машины с открытой крышей\",\n    \"в каком месяце лучше всего собирать урожай покрышек\",\n    \"сможешь подобрать маленькую машину для одного человека?\",\n    \"нужен внедорожник\",\n    # Дополнительные вопросы\n    \"покажи электромобиль до 3 млн\",",
        "detail": "test_query",
        "documentation": {}
    },
    {
        "label": "test_model_recognition",
        "kind": 2,
        "importPath": "test_tiggo_recognition",
        "description": "test_tiggo_recognition",
        "peekOfCode": "def test_model_recognition():\n    \"\"\"Тестируем распознавание модели 'тиго макс 7 про'\"\"\"\n    test_queries = [\n        \"тиго макс 7 про\",\n        \"тигго макс 7 про\", \n        \"тиго 7 про макс\",\n        \"тигго 7 про макс\",\n        \"тиго макс 7 про макс\",\n        \"тиго 7 про\",\n        \"тиго 7\",",
        "detail": "test_tiggo_recognition",
        "documentation": {}
    },
    {
        "label": "test_query",
        "kind": 2,
        "importPath": "test_various_queries",
        "description": "test_various_queries",
        "peekOfCode": "def test_query(query, expected_type=None):\n    \"\"\"Тестирует один запрос\"\"\"\n    url = \"http://localhost:5000/api/chat\"\n    data = {\n        \"message\": query,\n        \"user_id\": \"test_user\"\n    }\n    try:\n        print(f\"\\n🔍 Тестируем: '{query}'\")\n        response = requests.post(url, json=data)",
        "detail": "test_various_queries",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "test_various_queries",
        "description": "test_various_queries",
        "peekOfCode": "def main():\n    \"\"\"Основная функция тестирования\"\"\"\n    print(\"🚀 Начинаем тестирование различных типов запросов\")\n    # Тестовые запросы\n    test_cases = [\n        # Простые запросы о наличии\n        (\"есть ли белые машины\", \"availability\"),\n        (\"найди красные автомобили\", \"availability\"),\n        (\"покажи синие машины\", \"availability\"),\n        # Запросы о характеристиках",
        "detail": "test_various_queries",
        "documentation": {}
    },
    {
        "label": "test_colors_with_csrf",
        "kind": 2,
        "importPath": "test_with_csrf",
        "description": "test_with_csrf",
        "peekOfCode": "def test_colors_with_csrf():\n    base_url = \"http://localhost:5000\"\n    # Шаг 1: Получаем CSRF токен\n    print(\"🔑 Получаем CSRF токен...\")\n    try:\n        csrf_response = requests.get(f\"{base_url}/api/csrf-token\")\n        if csrf_response.status_code == 200:\n            csrf_data = csrf_response.json()\n            csrf_token = csrf_data.get('token', '')\n            print(f\"✅ CSRF токен получен: {csrf_token[:20]}...\")",
        "detail": "test_with_csrf",
        "documentation": {}
    },
    {
        "label": "UserAnalytics",
        "kind": 6,
        "importPath": "user_analytics",
        "description": "user_analytics",
        "peekOfCode": "class UserAnalytics:\n    \"\"\"Система аналитики пользовательского поведения\"\"\"\n    def __init__(self):\n        self.user_history = UserHistory()\n        self.init_analytics_tables()\n    def init_analytics_tables(self):\n        \"\"\"Инициализирует таблицы для аналитики\"\"\"\n        with get_db() as conn:\n            cursor = conn.cursor()\n            # Таблица сессий пользователей",
        "detail": "user_analytics",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "user_analytics",
        "description": "user_analytics",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass UserAnalytics:\n    \"\"\"Система аналитики пользовательского поведения\"\"\"\n    def __init__(self):\n        self.user_history = UserHistory()\n        self.init_analytics_tables()\n    def init_analytics_tables(self):\n        \"\"\"Инициализирует таблицы для аналитики\"\"\"\n        with get_db() as conn:\n            cursor = conn.cursor()",
        "detail": "user_analytics",
        "documentation": {}
    },
    {
        "label": "UserHistory",
        "kind": 6,
        "importPath": "user_history",
        "description": "user_history",
        "peekOfCode": "class UserHistory:\n    \"\"\"Класс для управления историей пользователя\"\"\"\n    def __init__(self):\n        self.init_user_tables()\n    def init_user_tables(self):\n        \"\"\"Инициализирует таблицы для пользователей\"\"\"\n        with get_db() as conn:\n            cursor = conn.cursor()\n            # Таблица истории запросов\n            cursor.execute('''CREATE TABLE IF NOT EXISTS user_queries (",
        "detail": "user_history",
        "documentation": {}
    },
    {
        "label": "user_history",
        "kind": 5,
        "importPath": "user_history",
        "description": "user_history",
        "peekOfCode": "user_history = UserHistory()",
        "detail": "user_history",
        "documentation": {}
    }
]